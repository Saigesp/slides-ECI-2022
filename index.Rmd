---
title: "Analizando datos, visualizando informaci√≥n, contando historias"
subtitle: "Curso de la ECI 2022"
author:
  - "Autores: Javier √Ålvarez Li√©bana y Gabriel Valverde Castilla"
institute: "Facultad de Estudios Estad√≠sticos (UCM)"
date: "31/01/2022 - 04/02/2022 (actualizado: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    self_contained: false
    lib_dir: libs
    css: [default, style.css]
    nature:
      # beforeInit: "stylejs.js"
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: true
---


```{r settings, include = FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(fig.retina = 3, out.width = "100%", cache = FALSE,
                      comment = ">", echo = TRUE, message = FALSE,
                      warning = FALSE, hiline = TRUE, dpi = 300)

# xaringan Extra
# devtools::install_github("gadenbuie/xaringanExtra")
library(xaringanExtra)
use_xaringan_extra(c("tile_view", "animate_css", "tachyons"))
use_tile_view() # panel
# xaringanExtra::use_scribble() # scribble
use_extra_styles(hover_code_line = TRUE,
                 mute_unhighlighted_code = FALSE) # Hover triangle code line
use_clipboard( # About clipboard
  button_text = "Click para copiar c√≥digo",
  success_text = "C√≥digo copiado",
  error_text = "Ctrl+C para copiar"
)
use_freezeframe() # restarting gifs
use_animate_all("fade") # animates
use_panelset() # panels 
```

class: inverse center middle

# PRESENTACI√ìN DEL CURSO



$$\\[2.7in]$$

.left[Pulsa <kbd-black>O</kbd-black> para ver el panel de diapositivas]
.left[Pulsa <kbd-black>H</kbd-black> para ver otros atajos]

---


# Material del curso

<img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/imagen_curso.jpeg" alt = "course-ECI" align = "right" width = "360" style = "margin-top: 20vh;margin-right: 0.5rem;margin-left: 1rem;">

- **Web** del curso:

<https://dadosdelaplace.github.io/curso-dataviz-ECI-2022>



- **Diapositivas** del curso ([**c√≥digo R de las diapositivas**](https://github.com/dadosdelaplace/slides-ECI-2022)):

<https://dadosdelaplace.github.io/slides-ECI-2022>



- **Manual** del curso ([**c√≥digo R del manual**](https://github.com/dadosdelaplace/courses-ECI-2022)):

<https://dadosdelaplace.github.io/courses-ECI-2022>



- **Scripts** del curso:

<https://github.com/dadosdelaplace/courses-ECI-2022/tree/main/scripts>


&nbsp;

- **Grupo de Telegram** para dudas, preguntas y dem√°s cosicas:

<https://t.me/curso_dataviz_ECI>

---


# Objetivos

<img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/imagen_curso.jpeg" alt = "course-ECI" align = "right" width = "360" style = "margin-top: 20vh;margin-right: 0.5rem;margin-left: 1rem;">

¬°Bienvenidos/as/es!

Tomen asiento, entren a la secta del **software libre** y dejen sus Excel en la entrada



El **objetivo** del curso no es ser un/a sesudo/a programador/a de `R`, sino adquirir los suficientes conocimientos como para lograr 5 objetivos:


- **Perder el miedo** a programar.
- Entender los [**conceptos b√°sicos de R**](https://cran.rstudio.com/), lenguaje estad√≠stico por excelencia, desde cero.
- Dotarnos de **autonom√≠a en el an√°lisis** de datos.
- Crear programas y flujos de trabajo **reproducibles** y mantenibles.
- Adquirir habilidades en la **visualizaci√≥n de datos** en `R` (haciendo uso tambi√©n de otras herramientas como [**Datawrapper**](https://www.datawrapper.de/)), incluyendo la visualizaci√≥n de datos en **mapas**.


&nbsp;

üìö Estas **diapositivas** han sido elaboradas con el propio `R` haciendo uso del paquete `{xaringan}`
y `{xaringanExtra}`.

---

# A programar se aprende programando

<video width = "1000" height = "480" align = "middle" controls>
  <source src = "./img/programming_skills.mp4" type = "video/mp4">
</video>

**Desmitifiquemos** la programaci√≥n: es cuesti√≥n de pr√°ctica, de tiempo, de pruebas y de muchos errores. **Desdramaticemos** equivocarnos con un ordenador.

---

class: inverse middle

### BLOQUE I. Introducci√≥n a R desde cero

* Instalaci√≥n de R y RStudio. Primeros pasos. Tipos de datos.
* Datos estructurados: matrices y data.frame
* Extras: estructuras de control, proyectos, funciones y datos en formato tibble


### BLOQUE II. Introducci√≥n a dataviz y  estad√≠stica con R

* Introducci√≥n a estad√≠stica b√°sica: centralizaci√≥n y dispersi√≥n, conceptos de regresi√≥n e inferencia.
* Tidy data. Introducci√≥n a Tidyverse
* Dataviz: la importancia de visualizar datos. Introducci√≥n a ggplot2. Visualizaci√≥n en tablas

### BLOQUE III. Periodismo de datos

Impartido por Borja Andrino, Javier √Ålvarez Li√©bana y Gabriel Valverde Castilla.

### BLOQUE IV. Story Telling

Impartido por Vict√≤ria Oliveres, Javier √Ålvarez Li√©bana y Gabriel Valverde Castilla.

### BLOQUE V. Visualizaci√≥n de datos en mapas

Impartido por Dominic Roy√©, Javier √Ålvarez Li√©bana y Gabriel Valverde Castilla.

---

class: inverse center middle

# Bloque I: introducci√≥n a R desde cero.

&nbsp;

### [Instalaci√≥n y primeros pasos](#instalacion-primeros-pasos)

### [Celdas: tipos de datos](#tipos-datos)

### [Columnas: vectores](#vectores)

### [Tablas: estructuras de datos](#matrices-dataframes)

### [Extras: estructuras de control](#estructuras)

### [Primer proyecto. Funciones](#proyecto-funciones)

### [Mejorando los datos: tibble](#tibble)

### [Caso pr√°ctico: informe RMarkdown](#rmarkdown)

### [üèÖEvaluaci√≥n](#evaluacion)

---
name: instalacion-primeros-pasos
class: center, middle

# Instalaci√≥n y primeros pasos

## **Instalaci√≥n de R**

&nbsp;

Programaremos como escribimos un libro: necesitamos una **gram√°tica** (`R`) y un **Word** (`RStudio`).

---

# Requisitos del curso

Para el presente curso los √∫nicos **requisitos** ser√°n:

1. **Conexi√≥n a internet** (para la descarga de algunos datos y paquetes).

2. **Instalar R**: ser√° nuestro **lenguaje**, nuestro **castellano** para poder ¬´comunicarnos con el ordenador. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

3. **Instalar R Studio**. De la misma manera que podemos escribir castellano en un ordenador, en un Word, en un papel o en un tuit, podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea m√°s c√≥modo. Nuestro **Word** para nosotros ser√° **RStudio**.

.left[
  <img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "500" style = "margin-top: 5vh">
]
.right[
  <img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/R-studio.jpg" alt = "RStudio" align = "right" width = "500" style = "margin-top: 5vh;">
]

---

# Instalaci√≥n de R

El **lenguaje de programaci√≥n R** ser√° nuestra **gram√°tica**, nuestra ortograf√≠a y nuestro diccionario

&nbsp;

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/pantalla1_cran.jpg" alt = "cran-R" align = "right" width = "500" style = "margin-top: 10vh;margin-right: 0.5rem;margin-left: 1rem;">

* **Paso 1**: entra en la [web oficial de R](https://cran.r-project.org/) y selecciona la instalaci√≥n acorde a tu sistema operativo.

* **Paso 2**: para **Mac** basta con que hacer click en el archivo **.pkg**, y abrirlo una vez descargado. Para sistemas **Windows**, debemos clickar en `install R for the first time` y en la siguiente pantalla hacer click en `Download R for Windows`. Una vez descargado, **abrirlo como cualquier archivo de instalaci√≥n**.

* **Paso 3**: abrir el **ejecutable** de tu escritorio o en tu Launchap (en Windows puede que tengas dos ejecutables i386 y x64, la versi√≥n de 32 y de 64 bits; haz click preferiblemente en el de x64).

---

# Primera operaci√≥n

Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta (en realidad se llama **consola**)

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/cranR.jpg" alt = "consola" align = "left" width = "350" style = "margin-top: 5vh;margin-right: 3rem;">

Vamos a escribir **nuestra primera operaci√≥n** en la consola:

* Una variable llamada `a` le asignaremos el valor `1`. En `R` asignaremos valores con `<-`, como una flecha: `a <- 1` significa que a una variable que llamamos a le asignamos el valor 1.

* Una variable llamada `b` le asignaremos el valor `2`.

* **Sumamos las variables** haciendo `a + b`.

```{r eval = FALSE}
# Primera operaci√≥n
a <- 1 # Una variable a con valor --> 1
b <- 2 # Una variable b con valor --> 2
a + b #<<
```

El **resultado** que nos devuelve la consola ser√° 3 (2 + 1).

```{r echo = FALSE}
a <- 1
b <- 2
a + b
```


---

# Instalaci√≥n de R Studio

El **Word**  que usaremos para trabajar y escribir en nuestro lenguaje ser√° **RStudio** (lo que se conoce como un IDE: entorno integrado de desarrollo).

&nbsp;

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/pantalla_rstudio.jpg" alt = "RStudio" align = "right" width = "450" style = "margin-top: 10vh;margin-right: 2rem;">

* **Paso 1**: entra la [web oficial de RStudio](https://www.rstudio.com/products/rstudio/download/#download) y selecciona la descarga gratuita.

* **Paso 2**: selecciona el ejecutable que te aparezca acorde a tu sistema operativo. 

* **Paso 3**: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalaci√≥n.


---

# Organizaci√≥n de RStudio

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_2.jpg" alt = "Rstudio" align = "left" width = "333" style = "margin-top: 3vh;margin-right: 2rem;margin-bottom: 1vh;">
<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_3.jpg" alt = "Rstudio" align = "left" width = "283" style = "margin-top: 3vh;margin-right: 2rem;margin-bottom: 1vh;">
<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_4.jpg" alt = "Rstudio" align = "left" width = "298" style = "margin-top: 3vh;margin-right: 2rem;margin-bottom: 1vh;">


&nbsp;



* **Consola**: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma) en ella. La consola ser√° donde **ejecutaremos √≥rdenes y mostraremos resultados**.

* **Environment (entorno de variables)**: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas, el tipo y su valor**.

* **Panel multiusos**: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **ayuda de funciones**, adem√°s de para **visualizar gr√°ficos**. 



---

# Tips de RStudio: modo oscuro


<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/menu_1.jpg" alt = "Rstudio" align = "left" width = "300" style = "margin-top: 3vh;margin-right: 2rem;">
<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/menu_2.jpg" alt = "Rstudio" align = "left" width = "350" style = "margin-top: 3vh;margin-right: 2rem;">

**Consejo**: cambiar en tu `RStudio` la tonalidad del fondo de tu programa, en tonos oscuros y no blancos.

---

# ¬øQu√© es R?

<img src = "https://logos.turbio.repl.co/rlang.svg" alt = "Rstudio" align = "left" width = "350" style = "margin-top: 3vh;margin-right: 2rem;">


&nbsp;



`R` es un **lenguaje estad√≠stico**, creado por y para la estad√≠stica, con 4 ventajas fundamentales:

--

* **Software libre** (como C++, Python, Fortran, y otros tantos lenguajes). El software libre no solo tiene una ventaja evidente (es gratis, ok) sino que permite **acceder libremente a c√≥digo ajeno**.

--

* **Lenguaje modular**: en la instalaci√≥n que hemos realizado no se han instalado todas las funcionalidades, solo el m√≠nimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de **c√≥digo hechos por otras personas llamados paquetes**, que podemos ir instalando a nuestro gusto seg√∫n los vayamos necesitando.

--

* **Gran comunidad de usuarios**: `R` tiene una comunidad de usuarios gigante para hacer estad√≠stica (Python tiene una enorme comunidad pero m√°s enfocada al Machine Learning), con m√°s de 18 000 paquetes.

--

* **Lenguaje de alto nivel**. Los lenguajes de alto nivel, como `R` o `Python`, facilitan la programaci√≥n al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser m√°s lentos en su ejecuci√≥n en comparaci√≥n con lenguajes de bajo nivel (`C`, `C++` o `Fortran`).

---

class: inverse center middle

COMPRAR un libro --> instalar un paquete (una sola vez) `install.packages()`
<figure>
<img src = "https://cdn.cienradios.com/wp-content/uploads/sites/14/2020/09/Book-Depository-2.jpg" alt = "comprar-libros" align = "middle" width = "480" style = "margin-top: 1vh;">
</figure>

SELECCIONAR un libro (ya comprado) --> acceder a un paquete ya instalado (en cada sesi√≥n que queramos usarlo) `library()`
<figure>
<img src = "https://cdn.sincroguia.tv/uploads/programs/l/a/-/la-biblioteca-de-los-libros-rechazados-704306_SPA-77.jpg" alt = "comprar-libros-2" align = "middle" width = "480" style = "margin-top: 1vh;">
</figure>


---

# Paquetes en R

Como hemos mencionado, existen trozos de **c√≥digo hechos por otras personas llamados paquetes**, que podemos ir instalando a nuestro gusto seg√∫n los vayamos necesitando.


&nbsp;


A lo largo del curso usaremos varios de esos paquetes, pero el m√°s importante para nuestro objetivo es el paquete `{ggplot2}`, un paquete para la **elaboraci√≥n de visualizaciones de datps**. Vamos a instalarlo (necesitamos internet para ello) con la orden `install.packages("ggplot")`

```{r eval = FALSE}
install.packages("ggplot2")
```


&nbsp;



La **instalaci√≥n de un paquete** es el equivalente a comprar a un libro: solo lo debemos hacer **la primera vez** que lo usemos en un ordenador (descarg√°ndose los archivos del paquete a nuestro local). Una vez que tenemos comprado nuestro libro, para poder usarlo, simplemente debemos **indicar al programa que nos lo acerque de la estanter√≠a** con `library(ggplot2)`.

```{r eval = FALSE}
library(ggplot2)
```

---

class: center middle

# ¬øPor qu√© no usar Excel?

![](./img/meme_barco.jpg)

---

class: inverse center middle

# ¬øPor qu√© no usar Excel?


<img src = "https://upload.wikimedia.org/wikipedia/commons/9/92/Soup_Spoon.jpg" alt = "cuchara" align = "middle" width = "600" style = "margin-top: 3vh;">


Excel es una excelente cuchara: puedes ser el mejor partiendo un filete con una cuchara, pero seguir√°s siendo una persona comiendo filete con cuchara.

---

# ¬øPor qu√© no usar Excel?

Excel es una **hoja de c√°lculo**, ni m√°s ni menos, y el propio **Microsoft desaconseja el uso de Excel para el an√°lisis de datos**. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de c√°lculo:

* Llevar las cuentas de tu familia.
* Una declaraci√≥n de Renta sencilla.
* Planificar viajes

&nbsp;

**NO EST√Å DISE√ëADO** para ser una base de datos, y muchos menos pensado para generar un entorno flexible para el an√°lisis estad√≠stico y la visualizaci√≥n de datos, con algunas desventajas:


* **Software de pago** (bien por el usuario, bien por la administraci√≥n o empresa).

* **Software cerrado**: solo podemos hacer lo que Excel ha cre√≠do que interesante que podamos hacer. Incluso con la programaci√≥n de macros, las funcionalidades de Excel siguen siendo mucho m√°s limitadas

* **Alto consumo de memoria**.

* **No es universal**: no solo es de pago sino que adem√°s, dependiendo de la versi√≥n que tengas de Excel, tendr√° un formato distinto para datos como fechas, teniendo incluso extensiones distintas.

---


# Epic fails en Excel


.pull-left[<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/excel_genes.jpg" alt = "Rstudio" align = "left" width = "250">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/excel_uk.jpg" alt = "Rstudio" align = "left" width = "250">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/excel_edades.jpg" alt = "Rstudio" align = "left" width = "250">]

.pull-right[



&nbsp;




## Problemas de **versiones**


&nbsp;



&nbsp;




## Problemas de **memoria**



&nbsp;



## Problemas de **codificaci√≥n**



]

---

# Primeros pasos en R: calculadora

Empecemos por lo sencillo: **¬øc√≥mo usar R como una calculadora?** Si escribimos `2 + 1` en la consola y pulsamos ENTER, la consola nos mostrar√° el resultado de la suma.

```{r}
2 + 1
```

&nbsp;

Si dicha suma la quisi√©ramos utilizar para un segundo c√°lculo: ¬øy si la **almacenamos en alguna variable**?

```{r}
x <- 2 + 1 #<<
x + 3
```

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/environment_1.jpg" alt = "environment" align = "right" width = "450">


```{r}
y <- 5
x + y
```

---

# Primeros pasos en R: calculadora

### Multiplicaci√≥n

```{r eval = FALSE}
x * y
```

### Elevar al cuadrado

```{r eval = FALSE}
x^2
```

### Valor absoluto

```{r eval = FALSE}
abs(x)
```

### Ra√≠z cuadrada

```{r warning = TRUE}
sqrt(-1)
```

---

# Errores

Durante tu aprendizaje va a ser **muy habitual que las cosas no salgan a la primera**, apareciendo en consola mensajes en un color rojo. Un miedo muy habitual cuando se empieza a programar es pensar que si haces algo mal o aparece alg√∫n mensaje de error, el **ordenador puede explotar en cualquier momento**. 

A **programar se aprende programando**, as√≠ que haz las pruebas que quieras.

---

# Mensajes de ¬´error¬ª


* **Mensajes de ERROR**: ir√°n precedidos de la frase `¬´Error in‚Ä¶¬ª`, y ser√°n aquellos **fallos que impidan la ejecuci√≥n del c√≥digo** (un error muy habitual es intentar acceder a funciones de alg√∫n paquete sin tenerlo instalado: est√°s intentando leerte un libro de tu biblioteca pero ni siquiera has ido a la tienda a ¬´comprarlo¬ª). Veamos un ejemplo intentando sumar un n√∫mero a un texto.

```{r error = TRUE}
"a" + 1
```

&nbsp;

* Mensajes **WARNING**: ir√°n precedidos de la frase `¬´Warning in‚Ä¶¬ª`, y son los fallos m√°s delicados ya que son posibles incoherencias pero que no van a hacer que tu c√≥digo deje de ejecutarse.

```{r warning = TRUE}
sqrt(-1)
```


**¬øHa ejecutado la orden?** S√≠, pero te advierte de que el resultado de la operaci√≥n es un NaN, _Not A Number_, un valor que no existe (al menos dentro de los n√∫meros reales).


---

# ¬øD√≥nde programamos? Script

Un **script** ser√° el documento en el que programamos, nuestro equivalente a un archivo `.doc`, pero aqu√≠ ser√° un archivo con extensi√≥n `.R`, donde escribiremos las √≥rdenes.

&nbsp;

Es **importante no abusar de la consola**: todo lo que no escribas en un script, cuando cierres `RStudio`, lo habr√°s perdido (c√≥mo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).

&nbsp;

Para **abrir nuestro primero script**, haz click en el men√∫ superior en `File << New File << R Script`.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_5.jpg" alt = "environment" align = "right" width = "450">


---

# Ejecutar nuestros scripts

Ahora tenemos una **cuarta ventana**: la ventana donde **escribiremos nuestros c√≥digos**

&nbsp;

### ¬øC√≥mo ejecutar nuestro script?

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_6.jpg" alt = "environment" align = "left" width = "550" style = "margin-top: 3vh;margin-right: 2rem;">


1. Escribimos el c√≥digo que queremos ejecutar (en este caso, la suma de antes).

2. Guardamos el archivo `.R` haciendo click en el bot√≥n de guardar (`Save current document`)

3. El c√≥digo **no se ejecuta salvo que se lo indiquemos**. Tenemos tres opciones:

  - **Copiar y pegar en consola** el c√≥digo.
  - **Seleccionar las l√≠neas de c√≥digo** a ejecutar y clickar en `Run` (o con su atajo).
  - Activar el cuadrado `Source on save` a la **derecha del bot√≥n de guardar**: no solo se nos guarda sino que se ejecuta el c√≥digo completo.


---

# Primeros ejercicios: trasteando con la consola


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: en tu consola asigna los valores 2 y 5 a dos variables `a` y `b`. Tras asignarles valores, multiplica los n√∫meros en consola.

* üìù **Ejercicio 2**: modifica el c√≥digo inferior para definir dos variables `c` y `d`, con valores 3 y -1, y calcular la divisi√≥n `c/d`.

```{r eval = FALSE}
c <- # deber√≠as asignarle el valor 3
d <- # deber√≠as asignarle el valor -1

c ? d # modifica el c√≥digo para realizar una divisi√≥n 
```

* üìù **Ejercicio 3**: repite el ejercicio 1 pero ahora guarda el resultado de la multiplicaci√≥n final en una variable `c`. Para ver el resultado guardado en `c` escribe dicha variable en consola.

* üìù **Ejercicio 5**: repite el ejercicio 3 pero ahora escribe el c√≥digo en un script (`script01.R`). Ejecuta el c√≥digo.

]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
# Para poner comentarios en el c√≥digo se usa #

# Definici√≥n de variables
a <- 2
b <- 5

# Multiplicaci√≥n
a * b
```
]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
# Definici√≥n de variables
c <- 3
d <- -1

# Divisi√≥n
a / b
```
]

.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
# Variables
a <- 2
b <- 5

# Resultado
c <- a * b

# Muestro en consola
c
```
]

.panel[.panel-name[Soluci√≥n ej. 5]

<img src = "
https://dadosdelaplace.github.io/courses-ECI-2022/img/consola_multiplicacion_3.jpg" alt = "script01" align = "middle" width = "420" style = "margin-top: 1vh;">

Tienes todos los scripts en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/> (el  `script01.R` en concreto en <https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/script01.R>

]
]


---
name: tipos-datos
class: center, middle

# Tipos de datos 

## **Celdas: tipos de datos individuales**

&nbsp;

¬øDe qu√© tipo pueden ser los datos que tenemos contenidos en cada celda de una ¬´tabla¬ª?

---

# Datos: de la celda a la tabla

<img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/celdas.jpg" alt = "celdas" align = "center" width = "850" style = "margin-top: 1vh;">


* **Celda**: un dato de un tipo concreto.
* **Variable**: concatenaci√≥n de datos del mismo tipo.
* **Matriz**: concatenaci√≥n de variables del mismo tipo y longitud.
* **Tabla**: concatenaci√≥n de variables de distinto tipo pero igual longitud.

---

# Celdas: tipos de datos individuales

**¬øExisten variables m√°s all√° de los n√∫meros?**


&nbsp;

Piensa por ejemplo en los **datos guardados de una persona**:

* La edad o el peso ser√° un **n√∫mero**.
* Su nombre ser√° una cadena de **texto**.
* Su fecha de nacimiento ser√° precisamente eso, una **fecha**.
* A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una **variable binaria o l√≥gica** (`TRUE` si est√° soltero/a o `FALSE` en otro caso).

<img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/celdas.jpg" alt = "celdas" align = "center" width = "600" style = "margin-top: 1vh;">

---

# Variables num√©ricas

El **dato m√°s sencillo**, dato que ya hemos usado en nuestros primeros pasos como calculadora.

```{r eval = FALSE}
a <- 1
b <- 2
a + b
```

&nbsp;

En el c√≥digo anterior, tanto `a` como `b`, como la suma `a + b`**, son de tipo num√©rico**

```{r}
# Clase de las variables
class(a)

# Tipolog√≠a interna
typeof(a) #<<
```

**Operaciones**: con los datos num√©ricos podemos realizar todas las **operaciones aritm√©ticas** que se nos ocurrir√≠a hacer en una **calculadora**.

```{r}
b^3
```


---

# Variables de texto

No solo de n√∫meros viven los datos: imagina que adem√°s de la edad de una persona queremos guardar su nombre.

```{r}
edad <- 32
nombre <- "Javier"

class(nombre)
typeof(nombre)
```

&nbsp;

La variable `nombre` es de **tipo caracter**: una **cadena de texto** (conocido en otros lenguajes como string o char) entre **comillas**.

Las cadenas de texto son un **tipo especial de dato** con los que obviamente no podremos hacer operaciones aritm√©ticas, pero si podemos hacer **otras operaciones**.

---

# Nuestra primera funci√≥n: paste

Una **funci√≥n** es un **c√≥digo encapsulado**: ejecuta un c√≥digo en funci√≥n de unos **argumentos de entrada**. Nuestra primera funci√≥n ser√° `paste()`: dadas **dos cadenas de texto como argumento de entrada** nos permite pegarlas, indic√°ndole en el **argumento** `sep = ` el caracter que queremos entre medias.

```{r}
# todo junto, sin espacios, igual a paste0("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = "") 
```

```{r}
paste("Javier", "√Ålvarez") # separados por un espacio
```

```{r}
paste("Javier", "√Ålvarez", sep = ".") # separados por un punto .
```

**Argumentos por defecto**: `paste(nombre, apellido)` es equivalente a `paste(nombre, apellido, sep = " ")`. El argumento `sep` tiene un **valor por defecto** `sep = " "`: si no se le asigna otro, tomar√° ese por defecto

---

# Nuestro primer paquete: glue

Otra forma **m√°s intuitiva de trabajar con textos** es usar el **paquete** `{glue}`.


```{r eval = FALSE}
install.packages("glue") # solo la primera vez
library(glue)
```

```{r echo = FALSE}
library(glue)
```

Recuerda que `install.packages()` es solo necesario la primera que ¬´compramos el libro¬ª: cada vez que queramos usarlo bastar√° con `library()`.

&nbsp;

Con dicho paquete podemos **usar variables dentro de cadenas de texto**. Por ejemplo, vamos a crear ¬´la edad es de ... a√±os¬ª, donde la edad concreta la tenemos guardada en una variable `edad`.

```{r}
edad <- 32
glue("La edad es de {edad} a√±os")
```

---

# Variables l√≥gicas

Una **variable l√≥gica, binaria o booleana** es aquella que **solo puede tomar dos valores (en realidad pueden tomar un tercer valor, ausente):

* `TRUE`, verdadero, guardado internamente como un 1.
* `FALSE`, verdadero, guardado internamente como un 1.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```

&nbsp;

**NO son variables de texto**: "TRUE" es un texto (como rojo o azul), `TRUE` es una valor l√≥gico.

```{r error = TRUE}
TRUE + 1
"TRUE" + 1
```

---

# Condiciones l√≥gicas

Los valores l√≥gicos suelen ser **resultado de evaluar condiciones l√≥gicas**. Por ejemplo, imaginemos que queremos comprobar si una persona est√° o no soltero, con el **operador l√≥gico** `==` (¬ølo de la izquierda es igual a lo de la derecha) y su opuesto `!=` (distinto de).

```{r}
soltero <- TRUE # persona soltera
soltero == TRUE # ¬øest√° soltero?
soltero != TRUE # ¬øno est√° soltero?
```


Por el mismo razonamiento podemos **comparar si una variable num√©rica** cumple una condici√≥n. ¬øTiene la persona menos de 32 a√±os? Adem√°s de las comparaciones ¬´igual a¬ª  frente ¬´distinto¬ª, tambi√©n comparaciones de orden como `<, <=, > o >=`.

```{r}
edad <- 38
edad < 32
```

---

# Combinar condiciones l√≥gicas

Las **condiciones l√≥gicas pueden ser combinadas**, principalmente de dos maneras:

* **Intersecci√≥n**: **todas** las condiciones concatenadas se deben cumplir (conjunci√≥n y, operador `&`) para devolver un `TRUE`.

* **Uni√≥n**: basta con que **una** de las condiciones concatenadas se cumpla (conjunci√≥n o, operador `|`) para devolver un `TRUE`.

&nbsp;

Ejemplo: podr√≠amos preguntarnos si la persona tiene menos de 32 a√±os y est√° soltero (AMBAS deben cumplirse).

```{r}
edad < 32 & soltero
```

El resultado es `FALSE` ya que solo se cumple una de las condiciones. Si nos bastase con una (¬´¬øest√° soltero y/o tiene menos de 32 a√±os?¬ª), el valor devuelto ser√≠a `TRUE`

```{r}
edad < 32 | soltero
```

---

# Variables de tipo fecha

Las **variables de tipo fecha** son de un tipo muy especial: no son una simple cadena de texto "2021-04-21", representan un **instante temporal**.

```{r error = TRUE}
# Cadena de texto
fecha_char <- "2021-04-21"
fecha_char + 1
```

Para **convertirlo a una fecha** podemos usar la funci√≥n `as.Date()` 

```{r}
fecha_date <- as.Date("2021-04-21")
fecha_date 
fecha_date + 1
```

Dado que internamente es un n√∫mero, **podemos restar fechas** (d√≠as entre ambas), podemos sumar n√∫meros a fechas (fecha d√≠as despu√©s), etc.

```{r}
as.Date("2021-04-21") - as.Date("2021-02-15")
```

---

# Funcionalidades de fechas

**¬øC√≥mo obtener autom√°ticamente la fecha de hoy?**

```{r}
Sys.Date()
```

&nbsp;

**¬øC√≥mo convertir una cadena de texto a fecha?** Basta usar la funci√≥n `as.Date()`, pas√°ndole como argumento la fecha y su formato .

```{r}
as.Date("10-03-2020", "%d-%m-%Y") # con d√≠a-mes-a√±o (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con d√≠a-mes-a√±o (2 cifras)
```


Dentro del **paquete `{lubridate}` tenemos bastantes **funciones √∫tiles** para trabajar con fechas como las siguientes.

---

# Paquete lubridate


```{r eval = FALSE}
install.packages("lubridate") # solo la primera vez
library(lubridate)
```

```{r echo = FALSE}
library(lubridate)
```

```{r}
today()
fecha <- now()
year(fecha)
month(fecha)
fecha > ymd(20170131)
```

---

# Tips

El **paquete `{stringr}`** permite un **manejo m√°s complejo de cadenas de texto** (como el uso de expresiones regulares).

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/stringr.png" alt = "stringr" align = "right" width = "900">

---

# Tips

Si haces click en la consola y pulsas la flecha ¬´arriba¬ª del teclado, te ir√° apareciendo todo el **historial de √≥rdenes ejecutadas**. Es una manera de ahorrar tiempo para ejecutar √≥rdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando tabulador te autocompletar√° solo.

&nbsp;

Siempre que veas el s√≠mbolo `>` como √∫ltima l√≠nea en la consola significa que est√° listo para que le escribamos otra orden.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tip_consola_lista.jpg" alt = "stringr" align = "right" width = "600">


---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 1**: define una variable que guarde tu edad, otra con tu nombre, otra respondiendo a la pregunta ¬´¬øtengo hermanos?¬ª y otra con la fecha de tu nacimiento.
 

* üìù **Ejercicio 2**: define otra variable con tus apellidos y junta las variables nombre y apellidos en una sola variable `nombre_completo`.
 

* üìù **Ejercicio 4**: calcula los d√≠as que han pasado desde la fecha de tu nacimiento
 

* üìù **Ejercicio 5**: obt√©n una variable l√≥gica que nos diga si se cumplen (todas) las condiciones i) menor de 30 a√±os (`edad < 30`); ii) con hermanos (`hermanos == TRUE`); iii) nacido en 1990 o posterior (`fecha_nacimiento >= as.Date("1990-01-01")`).

* üìù **Ejercicio 6**: modifica el c√≥digo del ejercicio anterior para obtener una variable l√≥gica que nos diga si se cumplen (al menos) alguna de las condiciones i) menor de 30 a√±os; ii) con hermanos; iii) nacido en 1990 o posterior. Nos basta con que se cumple al menos una.
]

.panel[.panel-name[Soluci√≥n ej. 1]
```{r}
edad <- 32 # tipo numeric
nombre <- "Javier" # tipo caracter
hermanos <- TRUE # tipo hermanos
fecha_nacimiento <- as.Date("1989-09-10") # tipo fecha
```
]


.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
# Nombre
nombre <- "Javier"
# Apellidos
apellidos <- "√Ålvarez Li√©bana"

# Pegamos
library(glue)
nombre_completo <- glue("{nombre} {apellidos}")
nombre_completo

# Otra forma
nombre_completo <- paste(nombre, apellidos)
nombre_completo
```
]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
library(lubridate)
fecha_nacimiento <- as.Date("1989-09-10")
days(today() - fecha_nacimiento)
```
]

.panel[.panel-name[Soluci√≥n ej. 5]

```{r}
# Se tienen que cumplir todas
edad < 30 & fecha_nacimiento >= as.Date("1990-01-01") & hermanos

# otra forma
edad < 30 & fecha_nacimiento >= as.Date("1990-01-01") & hermanos == TRUE
```

]

.panel[.panel-name[Soluci√≥n ej. 6]

```{r}
# Se tienen que cumplir todas
edad < 30 | fecha_nacimiento >= as.Date("1990-01-01") | hermanos
```
]
]


---

name: vectores
class: center, middle

# Vectores


## **Variables: colecci√≥n de datos individuales de igual tipo**

&nbsp;

¬øC√≥mo **concatenar** edades de varias personas? ¬øC√≥mo ordenarlas?

---

# Vectores: concatenar elementos

Los **vectores o arrays** no son m√°s que una **concatenaci√≥n de elementos del mismo tipo** (de hecho un n√∫mero individual `x <- 1` es en realidad un vector de longitud uno).

Los crearemos con `c()` (c de concatenar), con sus **elementos entre par√©ntesis y separados por comas**. 

```{r}
edades <- c(32, 27, 60, 61)
edades
```

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/vectores_enviroment.jpg" alt = "stringr" align = "right" width = "350">


La **longitud de un vector** se puede calcular con `length()`

```{r}
length(edades)
```

Dado que un n√∫mero y un vector es lo mismo (con distinta longitud), podemos **concatenar a vectores uno tras otro**.

```{r}
c(edades, edades, 8)
```


---

# Secuencias num√©ricas

Es habitual **crear vectores num√©ricos con un patr√≥n** repetido. Hay un **atajo**: `seq()` nos permite crear una **secuencia desde un elemento inicial hasta un elemento final**, avanzando de uno en uno.

```{r}
seq(1, 11) # secuencia desde 1 hasta 11 de 1 en 1 (equivalente: 1:11)
11:1 # orden inverso
```

Tambi√©n podemos definir **otro tipo de distancia entre dos elementos consecutivos**

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

Otras veces nos interesar√° definir una secuencia con un **n√∫mero concreto de elementos**.

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 11
```

---

# Secuencias num√©ricas

**Vectores repetidos**: otro atajo, para definir vectores de elementos repetidos, es la funci√≥n `rep()` nos permite repetir un elemento un n√∫mero fijado de veces.

```{r}
rep(0, 7) # vector de 7 ceros
```

No solo podemos repetir un n√∫mero sino que podemos **repetir vectores enteros**.

```{r}
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

Esa repetici√≥n adem√°s podemos definirla tambi√©n de **forma intercalada**

```{r}
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```

---

# Vectores de texto


El concepto de vectores **no solo ata√±e a los n√∫meros**

```{r}
mi_nombre <- c("Mi", "nombre", "es", "Javier")
mi_nombre
```

Cuando tenemos un vector de caracteres podemos colapsarlos con `paste()`, esta vez con `collapse = ...`

```{r}
paste(mi_nombre, collapse = ".") # separados por un punto .
```

Podemos tambi√©n combinar vectores num√©ricos con caracteres.

```{r}
paste("persona", 1:5, sep = "_") # separado por una barra baja
```

---

# Vectores l√≥gicos

Los **vectores l√≥gicos** suelen aparecer de nuevo como la evaluaci√≥n de condiciones l√≥gicas.  Por ejemplo, si definimos el vector `x <- c(1.5, -1, 2, 4, 3, -4)`, ¬øqu√© numeros de x son menores que 2?

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 2 
``` 

El primer, segundo y sexto elemento del vector son los √∫nicos elementos (estrictamente) menores que 2, de ah√≠ que en el primer, segundo y sexto elemento aparezca un TRUE y en el resto un FALSE.

&nbsp;

Al igual que antes, las condiciones pueden ser **combinadas**

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 3 & x > 0 # Solo los que cumplen ambas condiciones
```

---

# Datos ausentes

* **NA** (not available): valores que no tenemos (por ejemplo, el dato de contagios covid los fines de semana).

```{r}
x <- c(1, NA, 3, NA, NA, 5, 6) # Vector num√©rico con datos faltante
x
2 * x
```

--

* **NaN** (not a number): resultado no permitido

```{r}
sqrt(-1)
```

```{r}
x <- c(1, NA, 3, 4, 6, 7, NaN, NA)
is.na(x)
```

---

# Operaciones aritm√©ticas con vectores

Toda **operaci√≥n aritm√©tica** que podamos hacer con un n√∫mero la vamos a poder a hacer con un vector de n√∫meros: la operaci√≥n se realizar√° en **CADA ELEMENTO** del vector (en otros lenguajes no siempre es as√≠).

```{r}
# Multiplicamos por 2 a CADA ELEMENTO del vector
z <- c(2, 4, 6)
2 * z
```

De la misma manera se pueden definir **sumas** de vectores.

```{r}
x <- c(1, 3, 5)
x + z
```

--

Dado que los valores l√≥gicos son guardados internamente como `0/1`  podemos usar operaciones aritm√©ticas con ellos.

```{r}
x <- c(1, 3, 5)
sum(x < 2) # sumamos el vector l√≥gico --> n√∫mero de valores TRUE
```

---

# Operaciones estad√≠sticas con vectores
 
Tambi√©n podemos realizar **operaciones estad√≠sticas** como la suma, la media o la mediana.

```{r}
y <- c(1, -4, 5, 0, 7)
sum(y)  # suma
mean(y) # media
```

**IMPORTANTE**: las operaciones con ausentes no funcionan (salvo que los eliminemos antes con `na.rm = TRUE`).

```{r error = TRUE}
y <- c(1, 2, NA, -5, 0)
sum(y)
sum(y, na.rm = TRUE)
```


---

# Seleccionar elementos

¬øY si del vector original queremos **EXTRAER UN SUBCONJUNTO**? La forma m√°s sencilla es **acceder al elemento i-√©simo** con el operador de selecci√≥n `[i]`, o en base a una **condici√≥n l√≥gica**



```{r}
edades <- c(20, 30, 32, NA, 61)
edades[3] # accedemos a la edad de la tercera persona
edades[c(3, 4)] #<<
edades[edades > 30]
```

Otras veces no querremos seleccionar un elemento sino **filtrarlo**, con el operador `[-i]`

```{r}
edades[-1]
```




---

# Nombrando vectores


`R` nos permite dar **significado l√©xico a nuestros datos**, pudiendo poner **nombres a los elementos** de un vector.

```{r}
x <- c("edad" = 31, "tlf" = 613910687, "cp" = 33007) # cada n√∫mero tiene un significado distinto
x
```

Esto es una ventaja ya que nos permite su **selecci√≥n usando dichos nombres**: los n√∫meros ya representan algo.

```{r}
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

Con la funci√≥n `names()` podemos, no solo consultar sino cambiar los nombres.

```{r}
names(x) # Consultamos nombres antiguos
names(x) <- c("a√±os", "m√≥vil", "direcci√≥n") # Cambiamos nombres
```

---

# Ordenar vectores

Una acci√≥n **muy habitual** es **ordenar los datos**: de menor a mayor edad, datos m√°s recientes vs antiguos, etc. Para ello tenemos la funci√≥n `sort()`: vamos a ordenar, por ejemplo, una colecci√≥n de edades.

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 32, 23, 77)
sort(edades) # orden de joven a mayor
```

Por defecto `sort()` ordena de menor a mayor: con `decreasing = TRUE` podemos ordenar de mayor a menor.

```{r}
sort(edades, decreasing = TRUE) 
```

Otra forma de ordenar un vector es **pedirle nos devuelva los √≠ndices de los elementos ordenados** con `order`, y luego usar dichos √≠ndices.

```{r}
x <- c(7, 1, 2, 6)
x[order(x)]
```

---

# Ejercicios con vectores

.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 1**: modifica el c√≥digo para crear un vector de nombre `vector_num` que contenga los n√∫meros 1, 5 y -7.

```{r eval = FALSE}
# Vector de n√∫meros
vector_num <- c(1)
```

* üìù **Ejercicio 2**: define un vector que contenga los n√∫meros `1, 10, -1 y 2`, y obt√©n la longitud del vector anterior vector_num.
 

* üìù **Ejercicio 4**: crea un vector con las palabras ‚ÄúHola‚Äù, ‚Äúme‚Äù, ‚Äúllamo‚Äù (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase est√© correctamente escrita en castellano. Tras hacerlo, a√±ade ‚Äúy tengo 30 a√±os‚Äù.
 
 
* üìù **Ejercicio 7**: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Despu√©s crea otra secuencia de longitud 7 que todos los n√∫meros sean 3.
 

* üìù **Ejercicio 9**: crea un vector con las edades de cuatro conocidos o familiares. Tras ello, determina cu√°les de ellos tienen menos de 20 a√±os, 30 a√±os o m√°s, menos de 40 a√±os y m√°s de 65 a√±os.

]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
# Vector de n√∫meros
vector_num <- c(1, 5, -7)
vector_num
```
]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
# Vector de n√∫meros
vector_num <- c(1, 10, -1, 2)
vector_num
```
]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "√Ålvarez", "Li√©bana")

# Pegamos
frase <- paste(vector_char, collapse = " ")
frase

# A√±adimos frase
glue("{frase} y tengo 30 a√±os.")
```
]

.panel[.panel-name[Soluci√≥n ej. 7]

```{r}
1:10
rep(3, 7) # secuencia repetida de treses
```
]

.panel[.panel-name[Soluci√≥n ej. 9]

```{r}
edades <- c(27, 32, 60, 61) # en mi caso, por ejemplo
edades < 20 # menos de 20 a√±os
edades >= 30 # 30 a√±os o m√°s
edades < 40 # menos de 40 a√±os
```
]
]



---

name: matrices-datafroames
class: center, middle



# Datos estructurados: colecci√≥n de variables


## **matrices: igual tipo y longitud**

&nbsp;

## **data.frame o tabla: distinto tipo pero igual longitud**

---

# Datos estructurados: colecci√≥n de variables


<img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/celdas.jpg" alt = "celdas" align = "center" width = "580" style = "margin-top: 1vh;">

Ya sabemos:

‚úÖ Los **tipos de datos** que puede contener una **celda**.

‚úÖ Como **concatenar celdas** obteniendo variables (vectores, datos del mismo tipo).

Lo que haremos a continuaci√≥n ser√° **juntar esas variables**: bien del **mismo tipo** (matrices), bien de **distinto tipo** (`data.frame`), en cualquier caso de **igual longitud**.

---

# Matrices: variables del mismo tipo

Cuando analizamos datos solemos tener **varias variables distintas de cada individuo**. Necesitamos una ¬´tabla¬ª que una distintas variables (de IGUAL longitud). Las **matrices** son una **concatenaci√≥n de variables, del mismo tipo e igual longitud**, dispuestas en columnas (normalmente cada fila representa un individuo y cada columna una variable). La concatenaci√≥n en columnas la haremos con `cbind()`.

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(60, 70, 80, 90)
datos_matriz <- cbind(estaturas, pesos) # Construimos la matriz por columnas
datos_matriz # nuestra primera matriz
```

```{r echo = FALSE}
knitr::kable(datos_matriz)
```

---

# Matrices


Tambi√©n podemos **construir la matriz por filas** con `rbind()`, que nos permite **a√±adir filas a una matriz o construirla desde cero** (aunque lo habitual es tener cada variable en una columna y cada individuo en una fila).

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

```{r echo = FALSE}
knitr::kable(rbind(estaturas, pesos))
```

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/datos_matriz_1.jpg" alt = "course-ECI" align = "right" width = "400" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

--

Podemos **visualizar la matriz** en un formato ¬´excelizado¬ª con la funci√≥n `View()`

```{r eval = FALSE}
View(datos_matriz)
```

---

# Matrices

.panelset[
.panel[.panel-name[Ejemplo] 

Veamos un ejemplo m√°s jugoso para practicar: una matriz con las edades, tel√©fonos y c√≥digos postales.


```{r}
edades <- c(14, 56, 31, 20, 68) # vector num√©rico de longitud 4
tlf <- c(NA, 683839390, 621539732, NA, NA)
cp <- c(33007, 28019, 37005, 18003, 28045)

# Construimos la matriz por columnas
datos_matriz <- cbind(edades, tlf, cp) 
datos_matriz
```
]

.panel[.panel-name[A√±adir columna] 

Con `cbind()` tambi√©n podemos **a√±adir una columna**

```{r}
cbind(datos_matriz, "estaturas" = c(160, NA, 181, 165, 173))
```
]

.panel[.panel-name[Dimensiones] 
Y podemos **ver sus dimensiones** con `dim()`, o por separado con `nrow()` y `ncol()`

```{r}
dim(datos_matriz)
c(nrow(datos_matriz), ncol(datos_matriz))
```

Dada una matriz tambi√©n podemos **¬´darle vuelta¬ª** (lo que se conoce como **matriz transpuesta**) con `t()`.

```{r}
t(datos_matriz)
```

]

.panel[.panel-name[matrix()] 

Igual que a veces es √∫til generar un vector de elementos repetidos, tambi√©n podemos definir una **matriz de n√∫meros repetidos** (por ejemplo, de ceros), con la funci√≥n `matrix()`, indic√°ndole el n√∫mero de filas y columnas.

```{r}
matrix(0, nrow = 4, ncol = 2) # 4 filas, 2 columnas, todo 0's
```

Tambi√©n podemos **definir una matriz a partir de un vector num√©rico**, reorganizando los valores en forma de matriz, sabiendo que los elementos se van colocando por columnas.

```{r}
z <- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)
z
```

]

.panel[.panel-name[Operaciones] 

Con las matrices sucede como con los vectores: cuando **aplicamos una operaci√≥n aritm√©tica se la estamos aplicando elemento a elemento**, por ejemplo, dividir entre 5 o sumar una constante

```{r}
datos_matriz / 5
datos_matriz + 3
```
]

.panel[.panel-name[Otras matrices] 

Tambi√©n podemos **crear matrices de otros tipos de datos**, siempre y cuando las columnas sean del mismo tipo e igual longitud.

```{r}
nombres <- c("Javier", "Carlos", "Mar√≠a", "Paloma")
apellidos <- c("√Ålvarez", "Garc√≠a", "P√©rez", "Li√©bana")
cbind(nombres, apellidos)
```

]
]

---

# Matrices

Las matrices son objetos **bidimensionales**: para acceder a la **fila i-√©sima** se usa el operador `[i, ]` (dejando el otro sin rellenar), para acceder a la **columna j-√©sima** se usa el operador `[, j]`. Para acceder **conjuntamente al elemento (i, j)** se  `[i, j]`. Tambi√©n podemos **acceder por nombres de las columnas**.


```{r}
datos_matriz[2, 3]
datos_matriz[1, ] # fila 1
datos_matriz[, 3] # columna 3
datos_matriz[1, c("edades", "tlf")] # por nombres
```

---

# Operaciones por filas y columnas (apply)

Imagina que tuvi√©semos nuestra matriz de estaturas y pesos.

```{r}
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

¬øC√≥mo podemos **obtener la media de cada columna**? Con la funci√≥n `apply()` le indicaremos

* la matriz
* el sentido de la operaci√≥n (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
* la funci√≥n a aplicar (en este caso, `mean`).

```{r}
# Media por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: modifica el c√≥digo para definir una matriz x de ceros de 3 filas y 7 columnas.
 
```{r eval = FALSE}
# Matriz
x <- matrix(0, nrow = 2, ncol = 3)
x
```

* üìù **Ejercicio 2**: a la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5.
 
 
* üìù **Ejercicio 4**: el siguiente c√≥digo define una matriz de dimensiones `4 x 3` y calcula la suma por columnas. Modifica el c√≥digo para que realice la suma por filas.
 
```{r eval = FALSE}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Suma por columnas
apply(matriz, MARGIN = 2, FUN = "sum")
```


* üìù **Ejercicio 5**: con la matriz anterior definida como `matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna.
]

.panel[.panel-name[Soluci√≥n Ej. 1]

```{r}
# Matriz
x <- matrix(0, nrow = 3, ncol = 7)
x
```

]

.panel[.panel-name[Soluci√≥n Ej. 2]

```{r}
(x + 1) / 5
```

]

.panel[.panel-name[Soluci√≥n Ej. 4]

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Suma por filas
apply(matriz, MARGIN = 1, FUN = "sum")
```

]

.panel[.panel-name[Soluci√≥n Ej. 5]

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

#  media de todos
mean(matriz)

# Media por filas (MARGIN = 1 ya que es una operaci√≥n por filas)
apply(matriz, MARGIN = 1, FUN = "mean")

# Media por filas (MARGIN = 2 ya que es una operaci√≥n por filas)
apply(matriz, MARGIN = 2, FUN = "mean")
```

]
]
 
---

# data.frame: tablas

**¬øQu√© sucede si a√±adimos una columna con los nombres de cada persona en nuestra matriz `datos_matriz`?** En dicha matriz ten√≠amos guardadas las edades, c√≥digos postales y tel√©fonos de una serie de personas, todas ellas variables num√©ricas.

```{r}
nombres <- c("Sonia", "Carla", "Pepito", "Carlos")
datos_matriz_nueva <- cbind(nombres, datos_matriz)
datos_matriz_nueva
```

Como una **matriz SOLO puede tener un tipo de dato**, al a√±adir una variable de tipo texto, `R` se ha visto obligado a convertir los n√∫meros en texto: hemos **roto la integridad** de los datos.

```{r, error = TRUE} 
datos_matriz_nueva[, "pesos"] + 1
```


---

# data.frame: tablas

El formato de tabla de datos en `R` que vamos a empezar a usar se llama `data.frame`, y no es m√°s que una **colecci√≥n de variables de igual longitud pero cada una puede ser de un tipo distinto**. Para crear un `data.frame` basta con usar la funci√≥n `data.frame()`.

```{r}
# Nombres
nombres <- c("Sonia", "Carla", "Pepito", "Carlos")
# Edades
edades <- c(45, 67, NA, 31)
# Estado civil (no lo sabemos de una persona)
casado <- c(TRUE, FALSE, FALSE, NA)
# Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
f_creacion <-
  as.Date(c("2021-03-04", "2020-10-12", "1990-04-05", "2019-09-10"))

# Creamos nuestro primer data.frame
tabla <- data.frame(nombres, edades, casado, f_creacion)
tabla
```

---

# data.frame: tablas

Al igual que con las matrices, podemos **crearlos** indicando adem√°s el **nombre de las columnas**.

```{r}
tabla <- data.frame("nombre" = nombres, "edad" = edades,
                    "casado" = casado, "fecha_registro" = f_creacion)
```


Si tenemos un `data.frame` ya creado podemos usar `data.frame()` tambi√©n para a√±adir una columna.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
tabla <- data.frame(tabla, "n_hermanos" = c(0, 0, 1, 5))
```

Con `View()` podemos **visualizar nuestra tabla**.

```{r echo = FALSE}
knitr::kable(tabla)
```

---

# Selecci√≥n de columnas y filas

Si queremos **acceder a una columna, fila o elemento** en concreto, los `data.frame` tienen las mismas ventajas que una matriz, as√≠ que bastar√≠a con usar los mismos operadores.

```{r}
tabla[, 3] # Accedemos a la tercera columna
tabla[4, ] # Accedemos a la cuarta fila
```

No solo tiene las ventajas de una matriz si no que tambi√©n tiene las ventajas de una **¬´base¬ª de datos**: podemos **aceder a las variables** por su nombre poniendo el nombre de la tabla m√°s el s√≠mbolo `$` y, con el tabulador, nos aparecer√° un **men√∫ de columnas** a elegir.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tabla_dolar.jpg" alt = "course-ECI" align = "right" width = "450" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 6**: el `data.frame` llamado `airquality`, del paquete `{datasets}`, contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973. Obt√©n el nombre de las variables.
 

* üìù **Ejercicio 7**: obt√©n las dimensiones del anterior conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?
 

* üìù **Ejercicio 8**: filtra del conjunto anterior solo los datos del mes de julio.

* üìù **Ejercicio 10**: q√∫edate solo con las variable Ozone y Temp.
 
* üìù **Ejercicio 13**: a√±ade a los datos originales una columna con la fecha completa (recuerda que es del a√±o 1973 todas las observaciones.

]

.panel[.panel-name[Soluci√≥n Ej. 6]

```{r}
# install.packages("datasets") si no estuviera ya instalado
library(datasets)
names(airquality)
```

]

.panel[.panel-name[Soluci√≥n Ej. 7]

```{r}
# Dimensiones
dim(airquality)
nrow(airquality)
ncol(airquality)
```

]

.panel[.panel-name[Soluci√≥n Ej. 8]

```{r}
filtro_filas <- airquality[airquality$Month == 7, ]
filtro_filas
```

]

.panel[.panel-name[Soluci√≥n Ej. 10]

```{r}
# Filtramos columnas
filtro_cols <- airquality[, c("Ozone", "Temp")]
filtro_cols
```

]

.panel[.panel-name[Soluci√≥n Ej. 13]

```{r}
# Construimos las fechas (pegamos a√±o-mes-d√≠a con "-")
fechas <- 
  as.Date(paste("1973", airquality$Month, airquality$Day,
                sep = "-"))

# A√±adimos
data.frame(airquality, fechas)
```

]

]

---

# Primer an√°lisis: datos de arrestos de EE.UU.


.panelset[
.panel[.panel-name[Carga]

El paquete llamado `{datasets}` contiene distintos conjuntos de datos reales

```{r}
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
```

Tras instalarlo, si escribimos `datasets::` y pulsamos tabulador, se nos abre un **desplegable con distintos conjuntos**. Vamos a practicar lo aprendido con `datasets::USArrests`, que contiene **estad√≠sticas de arrestos en 1973 (por cada 100 000 habitantes)**  en cada uno de los 50 estados de Estaods Unidos.

```{r}
datasets::USArrests
```

]

.panel[.panel-name[Detalles de datos]

**¬øQu√© tipo de objeto es?**

```{r}
class(datasets::USArrests)
```

**¬øC√≥mo buscar informaci√≥n de los datos?**

```{r eval = FALSE}
? datasets::USArrests
```

**¬øQu√© variables tenemos?**

```{r}
names(datasets::USArrests)
```

]

.panel[.panel-name[Dimensiones]

**¬øQu√© dimensiones tiene nuestro objeto?**
```{r}
dim(datasets::USArrests)
```

**¬øCu√°ntos estados tenemos con estad√≠sticas?**
```{r}
nrow(datasets::USArrests)
```

**¬øCu√°ntas variables se han medido en cada uno?**
```{r}
ncol(datasets::USArrests)
```
]


.panel[.panel-name[A√±adir columna]

En el conjunto de datos tenemos las **filas nombradas** (pero sin ser una variable).

```{r}
row.names(datasets::USArrests)[1:5] # los 5 primeros
```

**¬øC√≥mo podemos incluir dicho nombre como nueva columna?**

```{r}
tabla_nueva <- data.frame("estado" = row.names(datasets::USArrests),
                          datasets::USArrests)
row.names(tabla_nueva) <- NULL # ya no necesitamos los nombres de las filas
head(tabla_nueva) # Cabecera de la tabla
```

]

.panel[.panel-name[Selecci√≥n ¬´cl√°sica¬ª]

**¬øC√≥mo seleccionar solo las columnas `Murder` y `Assault` para el segundo y el d√©cimo estado?**

```{r}
USArrests[c(2, 10), c("Murder", "Assault")]
```

]

.panel[.panel-name[Subset]

Tenemos adem√°s a nuestro disposici√≥n una **herramienta muy potente**: la funci√≥n `subset()`. Dicha funci√≥n nos va a permitir **seleccionar filas y columnas a la vez** con argumentos:

* `x`: un `data.frame` de entrada.
* `subset`: **condici√≥n l√≥gica** para **seleccionar registros (filas)**.
* `select`: un vector que contenga el **nombre de las columnas que queremos seleccionar**.

Por ejemplo, vamos a seleccionar solo los **delitos de asesinato y agresi√≥n** de aquellos **estados** cuyo porcentaje de **poblaci√≥n urbana sea superior al 80%**.

```{r}
subset(USArrests, subset = UrbanPop > 80, select = c("Murder", "Assault"))
```


]
]

---

name: estructuras
class: center, middle

# Extra: estructuras de control

## **if-else y bucles**

&nbsp;

A veces necesitaremos algunas estructuras de control para guiar nuestro c√≥digo

---

# Estructuras if-else

`if-else` es una de las **estructuras de control** m√°s famosas: **SI** las condiciones impuestas se cumplen (`TRUE`), ejecuta las **√≥rdenes que tengamos dentro del `if {}`. 

```{r}
edades <- c(14, 17, 24, 56, 31, 20, 87, 73)
if (any(edades < 18)) { # TRUE si al menos una persona mayor de edad
  print("existe alguna persona mayor de edad")
}
```

```{r}
if (all(edades >= 18)) { # TRUE si TODOS son mayores de edad
  print("todas las personas son mayores de edad")
}
```

Si no se cumple no hace nada salvo que a√±adamos un `else {}` (con lo que sucede cuando no sucede)

```{r}
if (all(edades >= 18)) { # TRUE si TODOS son mayores de edad
  print("todas las personas son mayores de edad")
} else { # si hay alguno menor de edad 
  print("existe alguna persona menor de edad")
}
```


---

# Bucles (a evitar)

* `for`: bucle que permite **repetir** el mismo c√≥digo un **n√∫mero fijo** de veces.

```{r}
library(glue)
nombres <- c("Javi", "Laura")
edades <- c(32, 51)

# Recorremos cada uno de los nombres e imprimimos un mensaje que depende de i
for (i in 1:length(nombres)) { #<<
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
}
```

* `while`: **repetir** un **n√∫mero indeterminado** de veces hasta que se **deje de cumplir una condici√≥n**.

```{r}
ciclos <- 1
while(ciclos <= 3) { #<<
  print(paste("Todav√≠a no, vamos por el ciclo ", ciclos))
  ciclos <- ciclos + 1
}
```

---

name: proyecto-funciones
class: center, middle

# Primer proyecto. Uso de funciones

## **encapsulando y ordenando nuestro c√≥digo**

&nbsp;

Un proyecto ser√° una ¬´carpeta¬ª dentro de `RStudio`. Las funciones nos servir√°n para encapsular nuestro c√≥digo.

---

# Proyecto

Cuando se empieza a programar para un trabajo concreto de `R` es recomendable crearnos lo que se conoce como un **proyecto de trabajo**: en lugar de ir abriendo ventanas sueltas para programar, podemos agruparlos en proyectos, de forma que podamos acceder a ellos de forma **ordenada**

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto1.jpg" alt = "course-ECI" align = "left" width = "220" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto2.jpg" alt = "course-ECI" align = "middle" width = "220" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto3.jpg" alt = "course-ECI" align = "right" width = "250" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto4.jpg" alt = "course-ECI" align = "right" width = "250" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;">


---

# Funciones

No solo podemos usar las funciones predeterminadas, como `sum()` o `paste()`, sino que adem√°s podemos **crear nuestras propias funciones**, para automatizar **tareas que vayamos a repetir**

**¬øC√≥mo crear nuestra propia funci√≥n?** Veamos su **esquema b√°sico**:

* Un **nombre**, por ejemplo `nombre_funcion`.
* A dicho nombre le asignamos `<-` la palabra reservada `function()`.
* Dentro de `function()` definimos los **argumentos de entrada**.
* Dentro de `{}` incluiremos las √≥rdenes.
* Finalizaremos la funci√≥n con `return()` indicando lo que queremos **devolver**.

```{r eval = FALSE}
nombre_funcion <- function(argumento_1, argumento_2, ... ) {
  
  # C√≥digo que queramos ejecutar en la funci√≥n
  c√≥digo
  
  # Salida
  return(variable_salida)
}
```

**IMPORTANTE**: todas las variables que definamos dentro de la funci√≥n son **variables locales, solo existir√°n dentro de la funci√≥n** salvo que especifiquemos lo contrario.

---

# Funciones

Un **ejemplo muy simple**: una funci√≥n para **calcular el √°rea de un rect√°ngulo**. Los **argumentos de entrada** ser√°n los **lados** y el valor a **devolver** ser√° el √°rea (el producto de los lados).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {

  # Resultado que devolvemos
  return(lado_1 * lado_2)
  
}
```

**¬øC√≥mo aplicar la funci√≥n?**

```{r}
# Aplicaci√≥n de la funci√≥n con los par√°metros por defecto
calcular_area(5, 3) # √°rea de un rect√°ngulo 5 x 3 
```

---

# Funciones

Imagina que nos damos cuenta que el **90% de las veces el √°rea que nos toca calcular fuese la de un cuadrado**, es decir, solo necesitamos un argumento, un lado: `R` nos permite **definir argumentos por defecto** en la funci√≥n (tomar√°n dicho valor salvo que le asignemos otro).

**¬øPor qu√© no asignar `lado_2 = lado_1` por defecto?**

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

Ahora, **si no indicamos nada por defecto el segundo lado ser√° igual al primero** (un cuadrado).

```{r}
calcular_area(lado_1 = 5)
```

---

# Funciones

**Compliquemos un poco la funci√≥n** y a√±adamos en la salida los valores de cada lado.

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
}

salida <- calcular_area(lado_1 = 5, lado_2 = 3)
salida
salida["area"]
```

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r eval = FALSE}
# Definimos funci√≥n
nombre <- function(x, y) {
  # Sumamos
  suma <- # c√≥digo a ejecutar
  # ¬øQu√© devolvemos?
  return()
}
```

* üìù **Ejercicio 2**: modifica el c√≥digo para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto.

* üìù **Ejercicio 3**: modifica el c√≥digo para definir una funci√≥n llamada `funcion_producto`, pero que por defecto calcule el cuadrado.

* üìù **Ejercicio 4**: define una funci√≥n llamada igualdad_nombres que, dados dos `nombres persona_1` e `persona_2`, nos diga si son iguales o no. Hazlo considerando importantes las may√∫sculas, y sin que importen las may√∫sculas. Recuerda que con `toupper()` podemos pasar todo un texto a may√∫scula.

]

.panel[.panel-name[Soluci√≥n Ej. 1]

```{r}
# Definimos funci√≥n
funcion_suma <- function(x, y) {
  
  # Sumamos
  suma <- x + y
  
  # Devolvemos la salida
  return(suma)
}

# Aplicamos la funci√≥n
funcion_suma(3, 7)
```

]

.panel[.panel-name[Soluci√≥n Ej. 2]

```{r}
# Definimos funci√≥n
funcion_producto <- function(x, y) {
  
  # Multiplicamos
  producto <- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la funci√≥n
funcion_producto(3, -7)
```

]

.panel[.panel-name[Soluci√≥n Ej. 3]

```{r}
# Definimos funci√≥n
funcion_producto <- function(x, y = x) {
  
  # Multiplicamos
  producto <- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la funci√≥n
funcion_producto(3) # por defecto x = 3, y = 3
funcion_producto(3, -7)
```
]

.panel[.panel-name[Soluci√≥n Ej. 4]
```{r}
# Distinguiendo may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")

# Sin importar may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")
```
]

]
---

name: tibble
class: center, middle

# Mejorando los datos: tibble

![](./img/meme_gato.jpg)

## **mejorando los data.frame**

&nbsp;

Un **dato de tipo tibble** ser√° un `data.frame` mejorado: m√°s √°gil, m√°s r√°pido y m√°s c√≥modo.

---

# Resumen de datos

.pull-left[<img src = "https://miro.medium.com/max/727/0*MgEQsDgZZ7fJcdhZ.png" alt = "course-ECI" align = "left" width = "450" style = "margin-top: -5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

Imagen de https://medium.com/@tiwarigaurav2512
]

.pull-right[

* **Celdas**: num√©ricas, texto, l√≥gicas, fecha, etc.
* **Vectores**: variables, colecci√≥n de celdas del mismo tipo.
* **Matrices**: colecci√≥n de variables, del mismo tipo e igual longitud.
* **data.frame**: colecci√≥n de variables, de igual longitud pero cualquier tipo.


* `if-else`, bucles, funciones
]

Un dato que no hemos comentado son las **listas**: una colecci√≥n de variables de cualquier tipo y longitud.

```{r}
list("a" = 1:2, "b" = data.frame("d1" = 1:2, "d2" = 3:4))
```

---

# Tibble

Los **datos en formato tibble** (del paquete `{tibble}`) son un tipo de `data.frame` mejorado, para una **gesti√≥n m√°s √°gil, eficiente y coherente**. Las tablas en formato `tibble` tienen **4 ventajas principales**:

* Imprime **mayor informaci√≥n de las variables**, y solo **imprime por defecto las primeras filas**.

```{r}
library(tibble)
# tibble
tabla_tb <- tibble("x" = 1:30, "y" = rep(c("a", "b", "c"), 10),
                   "z" = 31:60, "logica" = rep(c(TRUE, TRUE, FALSE), 10))
tabla_tb
```

---

# Tibble

Los **datos en formato tibble** (del paquete `{tibble}`) son un tipo de `data.frame` mejorado, para una **gesti√≥n m√°s √°gil, eficiente y coherente**. Las tablas en formato `tibble` tienen **4 ventajas principales**:

* Mantiene la **integridad de los datos** (no cambia los tipos de las variables y hace una carga de datos inteligente).

```{r}
tibble("fecha" = as.Date(c("1989-01-01", "1989-02-01", "1989-03-01")),
       "valores" = 1:3)
```

---

# Tibble

Los **datos en formato tibble** (del paquete `{tibble}`) son un tipo de `data.frame` mejorado, para una **gesti√≥n m√°s √°gil, eficiente y coherente**. Las tablas en formato `tibble` tienen **4 ventajas principales**:

* La funci√≥n `tibble()` **construye las variables secuencialmente**.

```{r error = TRUE}
# data.frame
data.frame("x" = 1:3, "z" = 11:13, "x*z" = x * z)
```

```{r}
# tibble
tabla_tb <- tibble("x" = 1:3, "z" = 11:13, "x*z" = x * z)
tabla_tb
```

---

# Tibble

Puedes consultar **m√°s funcionalidades** de dichos datos en <https://tibble.tidyverse.org/>

Ahora adem√°s de poder ver una cabecera de las filas con `head()` tenemos la funci√≥n `glimpse()`, que nos permite **obtener el resumen de columnas**

```{r}
head(tabla_tb)
glimpse(tabla_tb)
```

Si ya tienes un `data.frame` es altamente recomendable **convertirlo a tibble** con `as_tibble()`

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: ¬øes el conjunto de datos `airquality` (del paquete `{datasets}`) de tipo tibble?
 

* üìù **Ejercicio 2**: convierte el conjunto `airquality` de `data.frame` a `tibble`.
 
* üìù **Ejercicio 3**: define un tibble con tres variables num√©ricas `a, b, c`, tal que la tercera sea el producto de las dos primeras `c = a * b`.
 

* üìù **Ejercicio 4**: define un `tibble` con tres variables de nombres variable, 2, tercera :), e intenta acceder a ellas.
 

* üìù **Ejercicio 5**: obten de los paquetes `{dplyr}` y `{gapminder}` los conjuntos de datos `starwars` y `gapminder`. Comprueba el n√∫mero de variables, de registros e imprime los datos.
]


.panel[.panel-name[Soluci√≥n Ej. 1]

```{r}
library(datasets)
head(airquality)
class(airquality)
```
]

.panel[.panel-name[Soluci√≥n Ej. 2]

```{r}
as_tibble(airquality)
class(as_tibble(airquality))
glimpse(as_tibble(airquality))
```

]

.panel[.panel-name[Soluci√≥n Ej. 3]

```{r}
tibble("a" = 1:5, "b" = 11:15, "c" = a * b)
```

]

.panel[.panel-name[Soluci√≥n Ej. 4]

```{r}
# Definimos el tibble
datos_tb <- tibble("variable" = 1:7, "tercera falsa :)" = 0, "2" = 11:17)
# Accedemos a sus columnas
datos_tb$variable
datos_tb$`tercera falsa :)`
datos_tb$`2`
```

]

.panel[.panel-name[5a]

```{r}
dplyr::starwars
dim(dplyr::starwars)
```

]

.panel[.panel-name[5b]

```{r}
library(gapminder)
gapminder
dim(gapminder)
```

]

]


---

name: rmarkdown
class: center, middle

# Caso pr√°ctico: informe RMarkdown

## **presentado nuestros an√°lisis**

&nbsp;

`Rmarkdown` es una herramienta para juntar en un mismo documento `markdown` (como el lenguaje marcado que se usa para wordpress o newsletter), c√≥digo `R`, im√°genes, f√≥rmulas, etc

---

# Rmarkdown

Vamos acabar nuestra primera sesi√≥n de `R` con una **forma pr√°ctica de presentar** nuestros an√°lisis y resultados, y que ser√° el formato en el que pedir√°n las **pr√°cticas evaluables**: hablemos de **Rmarkdown**.


Una de las principales **fortalezas** de `R` frente a `Python` es, no solo la visualizaci√≥n de datos, sino sus **opciones para generar informes**, incluso **libros**, **webs**, apuntes y hasta **diapositivas** (tanto el manual como estas mismas diapositivas han sido basadas en paquetes usan `{rmarkdown}`.

```{r eval = FALSE}
install.packages("rmarkdown")
```

<img src = "https://rubenfcasal.github.io/bookdown_intro/images/rmarkdown.png" alt = "rmd" align = "left" width = "280" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">


---


# Rmarkdown

**¬øCu√°l es la ventaja de generarlos desde rmarkdown?**

La m√°s obvia: lo podemos hacer desde `RStudio` sin salirnos del entorno de programaci√≥n, e integrar f√°cilmente **c√≥digo R**.

<img src = "https://d33wubrfki0l68.cloudfront.net/87603549ad0d95b0071da0f9270b2f89ead3b39b/48700/lesson-images/websites-1-render.png" alt = "rmd" align = "left" width = "500" style = "margin-top: 3vh;margin-right: 3rem;margin-left: 0.5rem;">

**¬øQu√© es Rmarkdown?**

Una **herramienta** que nos permite crear de forma sencilla documentos:

* **Markdown**: creado en 2004 por John Gruber, y de uso libre, es un **¬´lenguaje¬ª que nos permite crear contenido** con un dise√±o legible, permitiendo la inclusi√≥n sencilla de p√°rrafos, negritas, cursivas, etc. Si acostumbras a escribir en **wordpress, blogs u otras plataformas**, seguramente hayas escrito de esta forma (sin saberlo quiz√°s).
* **Latex**:  para escribir notaci√≥n matem√°tica como $x^2$.
* **C√≥digo y salidas de R**.
* **Im√°genes**
* **Estilos (css, js, etc)**

---

# Rmarkdown

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/file_rmarkdown.jpg" alt = "rmd" align = "left" width = "300" style = "margin-top: 3vh;margin-right: 3rem;margin-left: 0.5rem;">


**Crear un Rmarkdown**: para crear el primero fichero con extensi√≥n `.rmd` (la extensi√≥n de los archivos `R Markdown`). Tras hacer click en el bot√≥n `File << New File << R Markdown`, nos aparecer√° un men√∫ con varias opciones.


<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/new_rmd.jpg" alt = "rmd" align = "left" width = "350" style = "margin-top: 3vh;margin-right: 3rem;margin-left: 0.5rem;">

* **Formatos de salida**: `.pdf`, `.html` (documento din√°mico, permite la interacci√≥n con el usuario, como una ¬´p√°gina web¬ª), `.doc` (nada recomendable)
* **T√≠tulo (title)**: t√≠tulo de nuestro documento. 
* **Autor (author)**: autor del documento.

---

# Rmarkdown


```{r echo = FALSE, out.width = '55%'}
knitr::include_graphics("./img/rmd_estructura.jpg")
```


Un fichero `.Rmd` se divide b√°sicamente en **tres partes**

* **Cabecera**: el inicio que hay entre `---` (los ajustes del documento general).
* **Texto**: texto escrito que con markdown podremos mejorar con **negritas** (escrito como `**negritas**`, con doble ast√©risco al inicio y final), _cursivas_ (`_cursivas_`, con barra baja al inicio y final) o destacar nombres de funciones o `variables de R`. Recuerda que puedes a√±adir adem√°s **ecuaciones** como $x^2$ (he escrito `$x^2$`, la ecuaci√≥n entre d√≥lares).
* **C√≥digo R**: las cajitas donde metamos nuestro c√≥digo `R` se llamar√°n **chunks**.

**IMPORTANTE**: salvo que indiquemos lo contrario con **chunks**, todo lo que vamos a escribir en el documento es texto. No c√≥digo R.

---

# Cabecera

La **cabecera est√°n en formato YAML**, y contiene los **metadatos** del documento: t√≠tulo, autor, fecha, estilos (si los tuvi√©semos), etc. Vamos a cambiar la cabecera que nos ha generado por defecto de la siguiente forma:

* **Title**: `"Probando Probando"`
* **author**: `"Se√±or X"`
* **date**: `"11/7/2014"`
* **output**: `html_document`

Le indicamos el **formato de salida**, en este caso un **documento HTML**.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/rmd_vacio.jpg" alt = "rmd" align = "left" width = "500" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# Cuerpo de texto

Para empezar nuestro documento escribiremos, por ejemplo, la siguiente frase

> Este material ha sido dise√±ado como complemento y recursos de apoyo al curso de la Escuela de Invierno de la UCM titulado ¬´Analizando datos, visualizando informaci√≥n, contando historias¬ª, celebrado presencialmente del 31 de enero al 4 de febrero de 2022 (16:00 a 21:00 horas, de lunes a viernes).

**Guardamos** el archivo `.Rmd` haciendo click en el bot√≥n Guardar y **tejeremos** nuestro documento haciendo click en el bot√≥n `Knit`.


<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/primer_html_rmd.jpg" alt = "rmd" align = "left" width = "400" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# A√±adiendo formato

Podemos **mejorar un poco el texto**:

* Vamos a a√±adir **negrita** a la frase `"curso de la Escuela de Invierno de la UCM"` (poniendo ** al inicio y al final).

--

* Vamos a√±adir **cursiva** a la palabra `"material"` (poniendo _ al inicio y al final).

--

* Vamos a√±adir un **enlace**, <https://www.ucm.es/eci//cursoecic02-pre>, asoci√°ndolo al t√≠tulo `¬´Analizando datos, visualizando informaci√≥n, contando historias¬ª`. Para ello el t√≠tulo lo ponemos entre corchetes y justo detr√°s el enlace entre par√©ntesis [¬´Analizando datos, visualizando informaci√≥n, contando historias¬ª](https://www.ucm.es/eci//cursoecic02-pre)

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/rmd_2.jpg" alt = "rmd" align = "left" width = "520" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

--

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/html_rmd_2.jpg" alt = "rmd" align = "left" width = "380" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# Chunks de c√≥digo

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/chunk_1.jpg" alt = "rmd" align = "left" width = "400" style = "margin-top: 2vh;margin-right: 1rem;margin-left: 0.5rem;">


Nuestras **cajas de c√≥digo** llamadas _chunks_ ser√°n altos en el camino en nuestro texto _markdown_ donde podremos incluir c√≥digo. Para incluir uno deber√° de ir **encabezado** de la siguiente forma.

--

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/rmd_3.jpg" alt = "rmd" align = "left" width = "530" style = "margin-top: 1vh;margin-right: 1rem;margin-left: 0.5rem;">

Dentro de la cajita **escribiremos c√≥digo R**, como lo ven√≠amos haciendo hasta ahora. Vamos por ejemplo a **definir dos variables y su suma**. Dentro de esos _chunks_ puedes **comentar c√≥digo** como hacemos habitualmente con `#`.

Tras tejer de nuevo y obtenemos ahora un documento que tiene una caja de c√≥digo y su salida, en este caso `x + y`.
 
---

# Etiquetando chunks

Los _chunks_ de c√≥digo pueden tener un **nombre o etiqueta** para poder referenciarlos de nuevo (y para no repetir c√≥digo). En la etiqueta no se pueden poner espacios, preferiblemente solo letras y guiones.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/chunk_repe_tag.jpg" alt = "rmd" align = "left" width = "500" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/html_tag_chunk.jpg" alt = "rmd" align = "left" width = "500" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;">


---

# Organizando el documento

El **documento podemos dividirlo en secciones y subsecciones**. Para ello usaremos la sintaxis de _markdown_, poniendo **almohadillas**: una `#` para secciones, `##` para subsecciones, `###` para subsubsecciones, etc. Vamos a crear una **secci√≥n principal** que sea `# Primer informe` y una **subsecci√≥n** que se titule `## Chunks de c√≥digo` donde incluiremos los dos chunks que tenemos hasta ahora.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/secciones_rmd.jpg" alt = "rmd" align = "left" width = "450" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">

Tambi√©n podemos **organizar nuestro documento** creando listas de √≠tems, usando `*` para cada uno de ellos.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/items_rmd.jpg" alt = "rmd" align = "left" width = "450" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# Ejecutando chunk a chunk

En cada _chunk_ aparece una bot√≥n de _play_: puls√°ndolo podemos tener la **ejecuci√≥n y salida de cada chunk** en nuestro `.Rmd`, sin tener que esperar a ¬´tejer¬ª (con Knit) todo el documento para ver lo que vamos ejecutando.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/play_chunk.jpg" alt = "rmd" align = "left" width = "500" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/chunk_ejecutado.jpg" alt = "rmd" align = "left" width = "500" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">

Adem√°s **podemos incluir c√≥digo R dentro de la l√≠nea de texto**.


<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/codigo_inline_rmd.jpg" alt = "rmd" align = "right" width = "450" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# Personalizando chunks

Los _chunks_ podemos **personalizarlos** con algunas opciones, pas√°ndolos como argumentos dentro de las llaves `{r etiqueta, ...}`.

* `include = FALSE`: se **ejecuta el c√≥digo** pero **no se muestra** ni c√≥digo ni resultados en la salida final (pero lo que se ejecuta puede ser usado en otros chunks futuros). Por ejemplo, `{r etiqueta, include = FALSE}`

* `echo = FALSE`: se **ejecuta el c√≥digo** y se **muestra el resultado** pero **no el c√≥digo** en la salida final. Por ejemplo, `{r etiqueta, echo = FALSE}`
 
* `eval = FALSE`: se **muestra** pero **no se ejecuta** el c√≥digo en la salida final.

* `message = FALSE`: se **ejecuta el c√≥digo** pero **no se muestran los mensajes** de salida que tendr√≠amos en consola (en caso de existir).

* `warning = FALSE`: se **ejecuta el c√≥digo** pero **no se muestran los warning** que tendr√≠amos en consola (en caso de existir).

* `error = TRUE`: se **ejecuta el c√≥digo** pero permite ejecutar el c√≥digo **con errores** mostrando los mensajes de error que tendr√≠amos en consola (en caso de existir).

Puedes ver las **diferentes salidas** en el archivo [primer_rmarkdown.Rmd](https://github.com/dadosdelaplace/courses-ECI-2022/blob/main/scripts/primer_rmarkdown.Rmd)


---

# Variables y ecuaciones

Tambi√©n podemos **incluir ecuaciones** haciendo uso de c√≥digo latex (entre dolares `$$`), as√≠ como nombres de variables.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/variables_rmd.jpg" alt = "rmd" align = "left" width = "600" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/variables_html.jpg" alt = "rmd" align = "left" width = "600" style = "margin-top: 2vh;margin-right: 0.5rem;margin-left: 0.5rem;">


---
name: evaluacion
class: center, middle

# EVALUACI√ìN

## **Pr√°ctica evaluable I: informes en Rmarkdown**

&nbsp;

En la carpeta [EVALUACI√ìN](https://github.com/dadosdelaplace/courses-ECI-2022/tree/main/EVALUACI%C3%93N), accede al fichero `Evaluacion_1.Rmd` en la carpeta `PR√ÅCTICA I`. Dicho archivo es una plantilla de archivo `.Rmd` en el que se te hacen diferentes preguntas sobre un conjunto de datos y debes responderlas dentro del propio fichero y estructura `.Rmd`.

&nbsp;

La **entrega de las cinco pr√°cticas** deber√°n ser enviadas por mail antes de las 23:59h del 11 de febrero, todas en un archivo comprimido (`.zip`, `.rar`, etc), con el nombre de el/la alumno/a.

---

class: center, middle

# Ma√±ana m√°s y mejor. ¬°Much√≠simas gracias a todos/as!

Las diapositivas han sido generadas con el paquete [**{xaringan}**](https://github.com/yihui/xaringan).


Los estilos (.css y .js) de estas diapositivas est√°n basados en las diapositivas del repositorio <https://github.com/dieghernan/rpubs>

---

class: inverse center middle

# Bloque II: introducci√≥n al dataviz en R.

&nbsp;

### [Repaso](#repaso-1)

### [Tidy data: ordenando los datos](#tidy-data)

### [Introducci√≥n a Tidyverse](#tidyverse)

### [Dataviz e introducci√≥n a ggplot2](#dataviz)

### [Introducci√≥n a la estad√≠stica](#stats)

### [Caso pr√°ctico: an√°lisis y dataviz de datos (c√≥mics y chocolate)](#caso-practico-2)

### [üèÖEvaluaci√≥n](#evaluacion-2)

---

name: repaso-1
class: center, middle

# Repaso

Previously on Breaking Bad...

![](https://occ-0-1722-1723.1.nflxso.net/dnm/api/v6/E8vDc_W8CLv7-yMQu8KMEC7Rrr8/AAAABeq9Fg04r6qPCr1dq7VKOglPPuluLbGBoyy60tgKnh9KsXWh5Y2VaY7jDWhrl4QQV1NhshZxCtLJrM_3V_WJc5J0p-eW.jpg?r=776)


---

# Repaso: tipos de datos


.pull-left[<img src = "https://miro.medium.com/max/727/0*MgEQsDgZZ7fJcdhZ.png" alt = "course-ECI" align = "left" width = "450" style = "margin-top: -5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

Imagen de https://medium.com/@tiwarigaurav2512
]

.pull-right[

* **Celdas**: num√©ricas, texto, l√≥gicas, fecha, etc.

```{r}
numero <- 1
texto <- "hola"
var_logica <- texto == "adios"
var_logica
```

]

---

# Repaso: tipos de datos


.pull-left[<img src = "https://miro.medium.com/max/727/0*MgEQsDgZZ7fJcdhZ.png" alt = "course-ECI" align = "left" width = "450" style = "margin-top: -5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

Imagen de https://medium.com/@tiwarigaurav2512
]

.pull-right[
* **Vectores**: variables, colecci√≥n de celdas del mismo tipo.

```{r}
vector_num <- 1:3 # vector num√©rico

glue("variable_{vector_num}") # vector de texto

vector_num < 3 # vector l√≥gico

length(vector_num) # Longitud vector

sum(vector_num) # Sumar vector num√©rico
```

]

---

# Repaso: tipos de datos


<img src = "https://miro.medium.com/max/727/0*MgEQsDgZZ7fJcdhZ.png" alt = "course-ECI" align = "left" width = "450" style = "margin-top: -5vh;margin-right: 0.5rem;margin-left: 0.5rem;">

* **Matrices**: colecci√≥n de variables, del mismo tipo e igual longitud.

```{r}
mat <- cbind("a" = 1:3, "b" = c(-1, 5, 6)) # construir matriz
mat

apply(mat, MARGIN = 2, FUN = mean) # media por columnas
```

---

# Repaso: tipos de datos


* **data.frame**: colecci√≥n de variables, de igual longitud pero cualquier tipo.

```{r}
df <- data.frame("nombre" = c("javi", "mar", "carlos"),
                 "hermanos" = 1:3, "soltero" = c(TRUE, NA, FALSE),
                 "fecha_nac" = as.Date(c("1989-01-01", "1989-02-02",
                                         "1989-03-03")))
df
df$nombre
```

---

# Repaso: tipos de datos


* **tibble**: data.frame optimizado.

```{r}
tb <- tibble("a" = 1:3, "b" = 4:6, "c" = a * b)
tb
glimpse(as_tibble(df))
```

---

# Repaso: tipos de datos

* **listas** compendio de variables, de cualquier tipo y longitud.

```{r}
lista <- list("celda" = 1, "vec" = c(1, 3, 5), "df" = df)
lista
```

---

# Repaso: estructuras de control y extras

* `if-else`: si se cumple la condici√≥n, un camino; en otro caso, camino alternativo.
* bucles: repetir √≥rdenes hasta un criterio de parada (bien hasta un num√©ro de iteraciones, bien hasta que se cumpla una condici√≥n)
* funciones: encapsular c√≥digo.
* proyectos: organizar scripts.
* rmarkdown: presentaci√≥n de resultados.


## Subset

* `subset`: **condici√≥n l√≥gica** para **seleccionar registros (filas)**.
* `select`: un vector que contenga el **nombre de las columnas que queremos seleccionar**.

```{r}
subset(USArrests, subset = UrbanPop > 85, select = c("Murder", "Assault")) #<<
```

---

class: center, middle

# **¬øDUDAS?**

![](https://elsitioderuife.files.wordpress.com/2012/10/lenny-simpsons.jpg)

---

name: tidy-data
class: center, middle

# Tidy data

## **Ordenando los datos**

&nbsp;

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio).

---

# Tidy data: filosof√≠a de trabajo

Hasta ahora solo le hemos dado importancia al ¬´qu√©¬ª pero no al **¬´c√≥mo¬ª manejamos los datos**.

```{r flujo-tidy-data2, echo = FALSE,  out.width = "60%", fig.align = "center", fig.cap = "Flujo deseable de datos seg√∫n Hadley Wickham, extra√≠da de https://r4ds.had.co.nz/wrangle-intro.html"}
knitr::include_graphics("./img/flujo_tidy_data.jpg")
``` 

La **organizaci√≥n de nuestros datos** es fundamental para que su preparaci√≥n y explotaci√≥n sea lo m√°s eficiente posible: la **limpieza y preprocesamiento** puede llevarnos hasta el 80% del tiempo en nuestro an√°lisis si no se hace forma correcta (Dasu and Johnson 2003).

--

El concepto **tidy data** fue introducido por **Hadley Wickham** como el primer paso a realizar del entorno de paquetes que posteriormente se fueron desarrollando bajo el nombre de `{tidyverse}`, desarrollando un flujo de trabajo desde la carga hasta la visualizaci√≥n


---

# Tidy data

Los **conjuntos tidy o datos ordenados** tienen tres objetivos principales:

1. **Estandarizaci√≥n** en su estructura.
2. **Sencillez** en su manipulaci√≥n.
3. Listos para ser **modelizados y visualizados**.

--

Para ello, los **datos ordenados o tidy data** deben cumplir:

* Cada **variable en una columna**.
* Cada **observaci√≥n/registro/individuo en una fila** diferente.
* Cada **celda con un √∫nico valor**.
* Cada **conjunto** o unidad observacional conforma una **tabla**.

```{r tidy-data, echo = FALSE,  out.width = "67%", fig.align = "center", fig.cap = "Infograf√≠a con datos ordenados (tidy data) extra√≠da de https://r4ds.had.co.nz/tidy-data.html"}
knitr::include_graphics("./img/tidy_data.png")
``` 

Lo contrario lo llamaremos **datos desordenados** o _messy data_. 

---

# Pipeline %>%

En este entorno de trabajo tendremos un **operador clave**: el **operador pipeline (%>%)**, el cual lo debemos interpretar como una **flecha que une nodos**, y nos servir√° para **concatenar operaciones sobre un conjunto de datos de forma legible**. Por ejemplo, si tuvi√©semos tres funciones `first()`, `second()` y `third()`, la opci√≥n m√°s inmediata ser√≠a anidar las tres funciones.

```{r eval = FALSE}
third(second(first(x)))
```

Con el **pipeline %>%** podremos escribir (y leer) la concetanci√≥n de izquierda a derecha

```{r eval = FALSE}
first(x) %>% second(x) %>% third(x)
```

&nbsp;

Dicho operador depende del paquete `{magrittr}`: para evitar esta dependencia (cuantos menos paquetes tengamos que cargar, mejor), desde la **versi√≥n 4.1.0 de R** disponemos de un operador pipeline nativo de R, el **operador |>** (disponible adem√°s fuera del entorno tidyverse).

Usaremos el **paquete `{tidyr}`** para pasar de _messy_ a _tidy data_

---

# Messy data: valores en el nombre

Veamos un primer ejemplo con el conjunto `table4a` del paquete `{tidyr}`.

```{r}
library(tidyr)
table4a
```

En este ejemplo de 3 filas y 3 columnas, tenemos dos columnas `1999` y `2000` que **no est√°n representando cada una a una sola variable**: ambas son la misma variable, solo que medida en a√±os distintos, **cada fila est√° representando dos observaciones (1999, 2000) en lugar de un solo registro**.

Lo que haremos ser√° **incluir una nueva columna llamada `year`** que nos marque el a√±o y otra `values` que nos diga el valor de la variable de inter√©s en cada uno de esos a√±os.

---

# pivot_longer: pivotando tablas


Con la funci√≥n `pivot_longer` del mencionado paquete le indicaremos lo siguiente:

* `cols`: el **nombre de las columnas a pivotar** (con comillas porque son n√∫meros, no texto como nombre).
* `names_to`: el nombre de la columna a la que vamos a mandar los valores que figuran ahora en los nombres de las columnas.
* `values_to`: el nombre de la columna a la que vamos a mandar los valores.

```{r}
table4a %>% pivot_longer(cols = c("1999", "2000"), names_to = "year",
                         values_to = "values") #<<
```

Ahora tenemos **un registro por fila, una variable por columna y cada celda representa un √∫nico valor**. Lo que hacemos con `pivot_longer()` es **¬´ampliar¬ª la tabla haci√©ndola m√°s larga (m√°s filas)** pero con menos columnas.

---

# Segundo ejemplo: relig_income

```{r}
relig_income[1:3, ]
```

Salvo la primera, el **resto de columnas tienen como nombre los valores de una variable en s√≠ misma (ingresos)**. Ahora en lugar de indicarle el nombre de todas vamos a indicarle **la columna que NO queremos pivotar**.

```{r}
# No necesitamos comillas en el nombre salvo que tengan caracteres que no sean letras
relig_income %>% pivot_longer(-religion, names_to = "ingresos", values_to = "frec") #<<
```

---

# Messy data: un registro en varias filas

Otro caso puede ser tener un mismo registro (datos de un mismo individuo) pero dividido en varias filas.

```{r}
table2[1:3, ]
```

Los registros con el mismo a√±o deber√≠an ser el mismo, es la misma informaci√≥n, pero est√°n divididos en dos filas. Lo que haremos ser√° lo opuesto a antes: con `pivot_wider()` **¬´ampliaremos¬ª la tabla a lo ancho**

```{r}
table2 %>% pivot_wider(names_from = type, values_from = count) #<<
```

---

# Messy data: m√∫ltiples valores en celda

```{r}
table3
```

En la columna `rate` hay **guardados dos valores, separados por /**, lo que hace que en **una celda no tenga un √∫nico valor**. La funci√≥n `separate()` nos permitir√° **separar los m√∫ltiples valores de la columna** (por defecto **localiza como separador cualquier caracter que no sea alfa-num√©rico**)

```{r}
table3 %>% separate(rate, into = c("cases", "population")) #<<
```

---

# Messy data: m√∫ltiples valores en celda

Si **queremos un caracter concreto para dividir** podemos indic√°rselo expl√≠citamente

```{r}
table3 %>% separate(rate, into = c("cases", "population"), sep = "/")
```

De la misma manera que **podemos separar columnas tambi√©n podemos unirlas**. Para ello vamos a usar la tabla `table5`: con la funci√≥n `unite()` vamos a **unir el siglo (en century) y el a√±o (en year)**.

```{r}
table5 %>% unite(date, century, year) #<<
```

---

# Convertir al tipo adecuado

Una opci√≥n muy √∫til que podemos usar al **aplicar la separaci√≥n de los m√∫ltiples valores** es **convertir los datos al tipo adecuado**. Los datos unidos en `rate` eran **caracteres** (no pod√≠an ser num√©ricos). Al separarlos, por defecto, aunque ahora ya son solo n√∫meros, **los separa como si fueran textos**. Con `convert = TRUE` podemos indicarle que identifique el tipo de dato y lo convierta.

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"), convert = TRUE)
```

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 1**: convierte en _tidy data_ el siguiente _data.frame_.

```{r}
tabla_tb <- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))
```

* üìù **Ejercicio 2**: convierte en _tidy data_ el siguiente _data.frame_.
 
```{r}
tabla_tb <- tibble("a√±o" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))
```

* üìù **Ejercicio 3**: convierte en _tidydata_ la tabla `table5` del paquete `{tidyr}`.

]

.panel[.panel-name[Soluci√≥n Ej. 1]

El problema es que las dos columnas con nombres de a√±o son en realidad valores que deber√≠an pasar a ser variables, as√≠ que deber√≠amos disminuir aplicar `pivot_longer()`.

```{r}
library(tidyr)
tabla_tb <- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))

# Aplicamos pivot_longer
tabla_tb %>% pivot_longer(cols = c("2020", "2021"),
                          names_to = "a√±o", values_to = "valores")
```


]


.panel[.panel-name[Soluci√≥n Ej. 2]

El problema es que las filas que comparten a√±o son el mismo registro (pero con dos caracter√≠sticas que tenemos divididas en dos filas), as√≠ que deber√≠amos disminuir aplicar `pivot_wider()`.

```{r}
tabla_tb <- tibble("a√±o" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))

# Aplicamos pivot_wider
tabla_tb %>% pivot_wider(names_from = "variable",
                         values_from = "valor")
```

]

.panel[.panel-name[Soluci√≥n Ej. 3]

Primero uniremos el siglo y las dos √∫ltimas cifras del a√±o para obtener el a√±o completo (guardado en a√±o). Tras ello deberemos separar el valor del ratio en denominador y numerador (ya que ahora hay dos valores en una celda), y convertiremos el tipo de dato en la salida para que sea n√∫mero.

```{r}
table5 %>%
  unite(a√±o, century, year, sep = "") %>%
  separate(rate, c("numerador", "denominador"), convert = TRUE)
```

]

]


---

name: tidyverse
class: center, middle

# Introducci√≥n a tidyverse

## **Manipulando (para bien) los datos**

&nbsp;

El conjunto de paquetes de `{tidyverse}` supuso un antes y un despu√©s en el preprocesamiento de los datos en `R`

---

# Entorno tidyverse

Aunque conocemos ya un formato amable de almacenar los datos, muchas veces los **datos no los tenemos en el formato deseado**, o directamente queremos realizar algunas **transformaciones en los mismos**. Para trabajar con los datos vamos a cargar `{tidyverse}`, un **entorno de paquetes para el manejo de datos**.

```{r eval = FALSE}
install.packages("tidyverse") # SOLO la primera vez
library(tidyverse)
```

```{r include = FALSE}
library(tidyverse)
```

```{r flujo-tidyverse, echo = FALSE,  out.width = "60%", fig.align = "center", fig.cap = "Imagen extra√≠da de https://sporella.github.io/datos_espaciales_presentacion/#30"}
knitr::include_graphics("https://dadosdelaplace.github.io/courses-ECI-2022/img/flujo_tidyverse.png")
``` 

---

# Entorno tidyverse

El **entorno tidyverse** es una de las **herramientas m√°s importantes en el manejo de datos en R**, una c**olecci√≥n de paquetes** pensada para el manejo, la exploraci√≥n, el an√°lisis y la visualizaci√≥n de datos, **compartiendo una misma filosof√≠a y gram√°tica**.

```{r flujo-tidyverse-2, echo = FALSE,  out.width = "90%", fig.align = "center", fig.cap = "Imagen extra√≠da de https://www.storybench.org/getting-started-with-tidyverse-in-r/"}
knitr::include_graphics("https://dadosdelaplace.github.io/courses-ECI-2022/img/flujo_tidyverse_1.png")
``` 

---

# Paquetes de tidyverse

* `{tidyr}`: para **adecuar los datos a tidy data**

* `{tibble}`: **mejorando los data.frame** para un manejo m√°s eficiente.

* Paquetes `{readr}` para una **carga r√°pida y eficaz de datos rectangulares** (formatos .csv, .tsv, etc). Paquete `{readxl}` para **importar archivos .xls y .xlsx**. Paquete `{haven}` para importar archivos desde **SPSS, Stata y SAS**. Paquete `{httr}` para **importar desde web**. Paquete `{rvest}` para **web scraping**.

* `{dplyr}`: una **gram√°tica de manipulaci√≥n de datos** para facilitar su procesamiento.

* `{ggplot2}`: una **gram√°tica para la visualizaci√≥n** de datos.

* Paquete `{stringr}` para un manejo sencillo de **cadenas de texto**. Paquete `{forcast}` para un manejo de **variables cualitativas** (en R conocidas como factores).

* `{purrr}`: manejo de **listas**.

* `{lubridate}` para el **manejo de fechas**.

&nbsp;

Puedes ver su **documentaci√≥n completa** en <https://www.tidyverse.org/>.

---

# Intro a tidyverse: conjunto starwars

Para nuestra **introducci√≥n de tidyverse** vamos a trastear con el conjunto de datos `starwars` del paquete `{dplyr}` (incluido en `{tidyverse}`).


.pull-left[

```{r luke-starwars, echo = FALSE,  out.width = "90%", fig.align = "left", fig.cap = "Imagen extra√≠da de https://rstudio-education.github.io/"}
knitr::include_graphics("https://rstudio-education.github.io/bootcamper/slides/02-visualize-data/img/luke-skywalker.png")
``` 
]

.pull-right[

```{r}
starwars
```

]

---

# Intro a tidyverse: conjunto starwars


```{r}
glimpse(starwars) #<<
```

Dicho conjunto de datos, extra√≠do de la [Star Wars API](https://swapi.dev/), recopila **14 variables para 87 personajes de Star Wars**. 

```{r}
dim(starwars)
```

---

# Intro a tidyverse: conjunto starwars

```{r}
print(starwars, n = 3, width = Inf)
```

* `int`: n√∫meros enteros (`height`).
* `dbl`: n√∫meros reales (`mass`, `birth_year`).
* `chr`: cadenas de texto (`name`, `hair_color`, `skin_color`, `eye_color`, `sex`, `gender`, `homeworld`, `species`).
* `list`: listas (`films`, `vehicles`, `starships`).

---

# Intro a tidyverse: conjunto starwars

Para los **datos de tipo lista** tenemos guardados las pel√≠culas de cada personaje, los veh√≠culos de cada uno y las naves de cada personaje. Por ejemplo, con `starwars$films` podemos extraer las pel√≠culas en las que aparecen los tres primeros personajes, basta con ejecutar (del conjunto starwars ‚Äì> accedemos a la variable films con `$`)

```{r}
starwars$films[1:3]
```

---

# dplyr: manipulando datos

```{r dplyr, echo = FALSE,  out.width = "63%", fig.align = "center", fig.cap = "Cheet sheet de las opciones del paquete dplyr para la manipulaci√≥n de datos extra√≠da de https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf"}
knitr::include_graphics("https://dadosdelaplace.github.io/courses-ECI-2022/img/dplyr.png")
``` 

---

# Operaciones con filas: seleccionar

Una de las **operaciones m√°s comunes** es **filtrar registros**: de todos los individuos de nuestro conjunto de datos, seleccionaremos parte de ellos. Para hacerlo tenemos principalmente **tres opciones**:

* **Seleccionar en base a alg√∫n filtro l√≥gico**: con `filter()`, se seleccionar√°n solo individuos que cumplan ciertas condiciones (por ejemplo, solo los mayores de tal edad). Dentro de `filter()` se incluir√°n las condiciones l√≥gicas a cumplir.


Por ejemplo, vamos a **filtrar solo aquellos personajes con ojos marrones**, es decir, con la condici√≥n `eye_color == "brown"`.

```{r}
starwars %>% filter(eye_color == "brown") #<<
```

---

# Operaciones con filas: filter()

Con `%>% filter()`, en **tan solo una l√≠nea**, hemos hecho m√°s de lo que parece: `R` ha ¬´recorrido¬ª (algo similar a un bucle) cada una de las filas y ha ido comprobando que filas cumplen la condici√≥n y cuales no.

El operador de comparaci√≥n `==` puede ser **cambiado por `!=`** (seleccionamos los que **NO TIENEN ojos marrones**).

```{r}
starwars %>% filter(eye_color != "brown")
```


---

# Operaciones con filas: filter()

Tambi√©n se pueden **seleccionar los personajes** que tienen los **ojos de una serie de colores** permitidos: con `%in%` le indicaremos que seleccione solo aquellas filas cuyo valor de la variable `eye_color` est√© **dentro de un conjunto de candidatos**.

```{r}
starwars %>% # con ojos marrones, azules o rojos
  filter(eye_color %in% c("brown", "blue", "red"))
```
  
---

# Operaciones con filas: filter()

Si es una variable num√©rica tambi√©n podemos **seleccionar por rango** con `between()`, por ejemplo, los personajes cuya altura est√° **entre** 120 y 160 cm.

```{r}
# Con between filtramos por rango
starwars %>% filter(between(height, 120, 160))
```

---

# Operaciones con filas: filter()

Las condiciones se pueden **concatenar** todo lo que queramos, pudiendo en pocas l√≠neas realizar un filtro complejo, por ejemplo, seleccionando los **personajes con ojos marrones Y ADEM√ÅS NO humanos**.

```{r}
starwars %>% filter(eye_color == "brown" & species != "Human")
```

Otro ejemplo: ojos azules o rojos, que no sean humanos, y con menos de 50 a√±os.

```{r}
starwars %>%  filter(eye_color %in% c("blue", "red") & species != "Human" & birth_year < 50)
```

---

# Operaciones con filas: seleccionar

Una de las **operaciones m√°s comunes** es **filtrar registros**: de todos los individuos de nuestro conjunto de datos, seleccionaremos parte de ellos. Para hacerlo tenemos principalmente **tres opciones**:


* **Seleccionar por su √≠ndice de fila**: con `[]` o `slice()`, se seleccionar√°n los individuos que ocupen cierta posici√≥n en la tabla (la fila que ocupa tal personaje).


```{r}
# slice: extramos filas por √≠ndice de fila.
starwars %>% slice(1) #<<
starwars[1, ]
```

---

# Operaciones con filas: slice()


Podemos **extraer varias a la vez**, por ejemplo, filtrando las filas quinta, s√©ptima y novena.

```{r}
# slice: extramos filas por √≠ndice de fila.
starwars %>% slice(c(5, 7, 9))
```

Tambi√©n podemos **usar una secuencia de √≠ndices a extraer**, por ejemplo solo las filas pares.

```{r}
starwars %>% slice(seq(2, 8, by = 2)) # filas pares hasta la octava
```

---

# Operaciones con filas: slice()

Disponemos adem√°s de opciones por defecto para directamente **extraer las m primeras o √∫ltimas filas** con `slice_head()` y `slice_tail()`.

```{r}
# Podemos extraer directamente las primeras o √∫ltimas filas
starwars %>% slice_head(n = 3) # 3 primeras filas 
```

```{r}
starwars %>% slice_tail(n = 2) # 2 √∫ltimas filas 
```

---

# Operaciones con filas: seleccionar

Una de las **operaciones m√°s comunes** es **filtrar registros**: de todos los individuos de nuestro conjunto de datos, seleccionaremos parte de ellos. Para hacerlo tenemos principalmente **tres opciones**:

* **Seleccionar aleatoriamente**: con `slice()`, se seleccionar√°n los individuos aleatoriamente.
 
```{r}
# Tambi√©n podemos hacer una extracci√≥n al azar de filas
starwars %>% slice_sample(n = 3) # 3 al azar
starwars %>% slice_sample(n = 3) # 3 al azar nuevas
```

---

# Operaciones con filas: slice_min()

Tambi√©n tenemos `slice_min()` y `slice_max()` que nos permite **extraer filas en funci√≥n del m√≠nimo y m√°ximo de una variable** (si hay empate, mostrar√° todas las filas aunque supere el n√∫mero indicado, salvo que `with_ties = FALSE`). Por ejemplo, vamos a filtrar con `slice_min(height, n = 2)` los 2 personasjes m√°s bajitos, y con `slice_max(mass, n = 3)` los 2 personajes m√°s pesados.

```{r}
# Podemos extraer filas en funci√≥n del m√≠n/m√°x de una variable
starwars %>% slice_min(height, n = 2) # los 2 m√°s bajitos
starwars %>% slice_max(mass, n = 2) # los 3 m√°s pesados
```

---

# Operaciones con filas: reordenar

Otra operaci√≥n habitual en las filas es **ordenarlas en funci√≥n del valor de alguna de las variables** con `arrange()`,  pas√°ndole como argumento el nombre de la variable que usaremos para la ordenaci√≥n. Por ejemplo, vamos a ordenar nuestra **tabla de personajes por altura, de bajitos a altos**.

```{r}
# Con arrange ordenamos en base al orden de la variable que introduzcamos
starwars %>% arrange(height) #<<
```

---

# Operaciones con filas: reordenar

Por defecto la ordenaci√≥n es de menor a mayor pero podemos invertirlo usando `desc()`.

```{r}
# Por defecto lo hace ascendente pero podemos cambiarlo
starwars %>% arrange(desc(height))
```

---

# Operaciones con filas: reordenar

La ordenaci√≥n tambi√©n puede **realizarse en base al valor de dos o m√°s variables**: ordenar√° las filas en base a la primera, en caso de empate usar√° la segunda, en caso de empate la tercera, y as√≠ sucesivamente. Vamos a ordenar los personajes por altura y, luego, por peso.

```{r}
# Un dato NA va siempre al final
starwars %>% arrange(height, desc(mass))
```

---

# Ejercicio

Como estar√°s imaginando podemos combinar varias acciones en pocas l√≠neas, filtrando a la vez que ordenamos el filtro resultante. 

.panelset[
.panel[.panel-name[Ejercicio]


* üìù Selecciona solo los personajes que sean humanos, hombres y de ojos marrones, para despu√©s ordernarlos en altura descendente y peso ascendente.

]

.panel[.panel-name[Soluci√≥n]

```{r}
# Podemos combinar varias acciones en pocas l√≠neas
starwars %>%
  filter(eye_color == "brown",
         species == "Human", sex == "male") %>%
  arrange(height, desc(mass))
```

]
]

---

# Operaciones con filas: eliminar

La misma l√≥gica que hemos usado para seleccionar filas podemos usarla para **eliminar filas** con `slice()`, simplemente **negando** la condici√≥n de filtrado. Por ejemplo, vamos a eliminar las 5 primeras filas.

```{r}
# Eliminamos por √≠ndices
starwars %>% slice(-(1:5)) # eliminamos las 5 primeras filas
```

---

# Operaciones con filas: duplicados

Otra opci√≥n es **eliminar filas duplicadas** con `distinct()`, pas√°ndole como argumentos el nombre de las variables que usaremos para quitar duplicados, por ejemplo, aquellos personajes con igual par de color de pelo y ojos.

```{r}
# Eliminamos registros con igual par (color_pelo, color_ojos)
starwars %>%
  distinct(hair_color, eye_color)
```
  
---

# Operaciones con filas: duplicados

Por defecto, solo ha extra√≠do las dos columnas en base a las cuales hemos eliminado duplicados. Si queremos que nos mantenga todas deberemos explicitarlo con `.keep_all = TRUE`.

```{r}
# Eliminamos duplicados
starwars %>% # Eliminamos registros con igual par (color_pelo, color_ojos)
  distinct(hair_color, eye_color, .keep_all = TRUE)
```

---

# Operaciones con filas: a√±adir

No suele ser habitual pero si quisi√©ramos a√±adir un nuevo registro manualmente, podremos hacerlo con `bind_rows()`, asegur√°ndonos que las **variables en el nuevo registro son las mismas que en el original**. Por ejemplo, vamos a a√±adir al fichero original los 3 primeros registros (al final).

```{r}
starwars_nuevo <- bind_rows(starwars, starwars[1:3, ]) #<<
dim(starwars)
dim(starwars_nuevo)
```

---

# Operaciones con columnas: seleccionar

La opci√≥n m√°s sencilla para **seleccionar variables/columnas** es usar `select()`, pas√°ndole como argumentos los nombres de columnas (¬°SIN COMILLAS!) que queremos seleccionar, por ejemplo, color de pelo.

```{r}
# seleccionamos solo 1 columna: color de pelo
starwars %>% select(hair_color) #<<
```

---

# Operaciones con columnas: seleccionar

Podemos **seleccionar varias a la vez concatenando sus nombres**, por ejemplo, seleccionando las variables de color de pelo, piel y ojos.

```{r}
# seleccionamos solo 3 columnas: pelo, piel y ojos
starwars %>% select(c(hair_color, skin_color, eye_color))
```

---

# Operaciones con columnas: seleccionar

La misma l√≥gica podemos aplicar para **deseleccionar**, excluyendo columnas

```{r}
# sin 3 columnas: pelo, piel y ojos
starwars %>% select(-c(hair_color, skin_color, eye_color))
```

---

# Operaciones con columnas: seleccionar

Las columnas tambi√©n las podemos **seleccionar a trav√©s de expresiones regulares**, por ejemplo, seleccionando solo aquellas columnas que compartan un **sufijo com√∫n** en el nombre, con `ends_with()` dentro de √≥rdenes como `select()`

```{r}
# Podemos seleccionar columnas por sufijo y prefijo
starwars %>% select(ends_with("color")) # acaban en "color"
```


---

# Operaciones con columnas: seleccionar

De una manera similar podemos seleccionar columnas cuyo **nombre empiecen o contengan alguna cadena de texto concreta**, con `starts_with()` o `contains()`.

```{r}
starwars %>% select(starts_with("h")) # empiezan por h
```

---

# Operaciones con columnas: seleccionar

Incluso nos permite **seleccionar aquellas columnas que son del mismo tipo** (imagina que necesitamos solo las columnas num√©ricas para calcular ciertas estad√≠sticas) con `where()`.

```{r}
# Seleccionamos solo la columnas num√©ricas
starwars %>% select(where(is.numeric))
```

---

# Visualizar el flujo de datos

Existe una **reciente herramienta** que nos va a permitir **entender mejor y visualizar el flujo de trabajo** en `{tidyverse}`: <https://tidydatatutor.com/>. 
Basta con poner el c√≥digo que queremos ejecutar, y nos **muestra visualmente las operaciones en los datos**.

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tidytutor3.jpg" alt = "course-ECI" align = "right" width = "450" style = "margin-top: 1vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tidytutor4.jpg" alt = "course-ECI" align = "right" width = "450" style = "margin-top: 1vh;margin-right: 0.5rem;margin-left: 0.5rem;">

<img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tidytutor5.jpg" alt = "course-ECI" align = "right" width = "400" style = "margin-top: 1vh;margin-right: 0.5rem;margin-left: 0.5rem;">

---

# Operaciones con columnas: renombrar

A veces tambi√©n podemos querer **modificar la ¬´metainformaci√≥n¬ª renombrando el orden** de las columnas. Para ello debremos usar la funci√≥n `rename()` poniendo **primero el nombre nuevo y luego el antiguo**. Como ejemplo, vamos a traducir el nombre de las columnas `name, height, mass` a castellano.

```{r}
# rename: renombrar columnas, primero el nuevo y luego el antiguo
starwars %>% rename(nombre = name, altura = height, peso = mass)
```

---

# Operaciones con columnas: renombrar

Muchas de las funciones pueden ir acompa√±adas de `at` o `if`, como `rename_if`, que nos permite hacer operaciones m√°s personalizadas. Por ejemplo, vamos a renombrar las columnas, pas√°ndolas a may√∫scula con toupper, pero solo aquellas que sean de tipo num√©rico.

```{r}
starwars %>% rename_if(is.numeric, toupper)
```

---

# Operaciones con columnas: reordenar

De la misma manera podemos **reordenar las columnas**, indicando el nombre de columnas que queremos mover, y con `.after` o `.before` para indicar antes o despu√©s de que columnas queremos moverlas.

```{r}
starwars %>% # altura y masa detr√°s de color de piel
  relocate(height, mass, .after = skin_color) 
```

  
---

# Crear nuevas variables (mutate)

A veces no queremos modificar variables ya existentes sino **crear nuevas variables** en base a las ya existentes. Para ello tenemos `mutate()`. Para empezar, vamos a crear una **nueva variable** `height_m` con la altura en cent√≠metros.

```{r}
# altura en metros
starwars %>% mutate(height_m = height / 100) %>%
  relocate(height_m, .after = height)
```

---

# Crear nuevas variables (mutate)

Otra opci√≥n es **quedarnos solo con las columnas nuevas** creadas con `transmute()`

```{r}
starwars %>% transmute(height_m = height / 100)
```

---

# Crear nuevas variables (mutate)

Tambi√©n se pueden aplicar **funciones m√°s complejas** como `map()` del paquete `{purrr}` para el manejo de **listas** (no se pueden vectorizar, esta funci√≥n nos permite aplicar operaciones a listas elemento a elemento). Imagina que queremos **calcular el n√∫mero de pel√≠culas** en las que sale cada personaje.

&nbsp;

Las pel√≠culas de cada personaje est√°n en una lista: para saber la **cantidad de pel√≠culas** en las que ha participado el primer personaje basta con usar el comando `length()` (nos dar√° el n√∫mero de elementos de cada lista).

```{r}
length(starwars$films[1])
length(starwars$films[2])
```

---

# Crear nuevas variables (mutate)

**¬øC√≥mo aplicar dicha a funci√≥n a cada personaje?** Con `map_int()` (para que nos devuelva un vector de `int`) y la funci√≥n a aplicar en cada elemento.

```{r}
# Mapeamos la lista con length pero devolvemos un vector de n√∫meros enteros
starwars$films %>% map_int(length)
```


&nbsp;

Tenemos tambi√©n otras funciones como `map_chr()`, `map_dfr()`, etc, que nos definen como ser√° la salida (con `map` a secas lo devuelve en una lista).

```{r}
starwars$films %>% map_chr(length)
```

---

# Crear nuevas variables (mutate)

Una vez que tenemos una forma de calcular la variable que queremos, lo a√±adimos con `mutate()`

```{r}
starwars %>%
  mutate("n_peliculas" = map_int(films, length)) %>%
  select(c(name, homeworld, n_peliculas))
```

  
---

# Recategorizar variables

Una operaci√≥n tambi√©n muy habitual es querer **recategorizar nuestras variables**: tenemos categor√≠as ya existentes o variables num√©ricas que queremos convertir a **categor√≠as (factores en R)**. Supongamos por ejemplo que queremos crear una **categor√≠a en funci√≥n de su altura**: menos de 120, entre 120 y 180, y m√°s de 180. Para ello podemos podemos usar `cut()`, y en el argumento `breaks` le debemos indicar los **¬´cortes¬ª o saltos de la variable**.

```{r}
starwars %>%
  mutate("estat_cat" = cut(height, breaks = c(-Inf, 120, 180, Inf))) %>%
  relocate(estat_cat, .after = height)
```

---

# Recategorizar variables

Si queremos que **las categor√≠as tenga nun nombre expl√≠cito** (y no el intervalo en s√≠), podemos indic√°rselo en `labels =` el vector de nombres de las categor√≠as.

```{r}
starwars %>%
  mutate("estat_cat" = cut(height, breaks = c(-Inf, 120, 180, Inf),
                           labels = c("bajos", "medios", "altos"))) %>%
  relocate(estat_cat, .after = height)
```

---

# Recategorizar variables

Otra opci√≥n para no anidar es `case_when`, en el que le podemos indicar que valores asignamos en funci√≥n de condiciones. Vamos a crear una variable nueva altura

* Si `height > 180` ‚Äì> ser√°n `"altos"`.
* Si `height <= 180` y `height > 120` ‚Äì> ser√°n `"bajos"`
* Si `height <= 120` y `height > 0` ‚Äì> ser√°n `"enanos"`
* Si no se cumple lo anterior ‚Äì> ser√°n `"ausentes"`

```{r}
starwars %>%
  transmute(altura = case_when(height > 180 ~ "altos",
                               height > 120 ~ "bajos",
                               height > 0 ~ "enanos",
                               TRUE ~ "ausentes"))
```
  
                        
---

# Datos ausentes

Por √∫ltimo, podemos **eliminar los registros ausentes** en alguna de sus variables con `drop_na()`.

```{r}
starwars %>% drop_na()
```

Podemos indicarle que nos elimine con datos ausentes solo en algunos campos en concreto.

```{r}
starwars %>% drop_na(mass, height, sex, gender, birth_year)
```


---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: del conjunto `starwars` encuentra todos los personajes cuyo peso est√© entre 60kg y 90kg y que adem√°s tengan los ojos que no sean azules.
 
* üìù **Ejercicio 2**: a√±adido al anterior, encuentra todos los personajes que adem√°s tengan menos de 100 a√±os.
 
* üìù **Ejercicio 3**: selecciona adem√°s solo  `name, mass, height, eye_color, birth_year`.
 
* üìù **Ejercicio 4**: a√±adido al filtro anterior, ordena los registros de m√°s pesados a m√°s ligeros, y al rev√©s.
 
* üìù **Ejercicio 5**: a√±adido al filtro anterior, ordena los registros (en orden ascendente) por altura y peso.
 
* üìù **Ejercicio 6**: selecciona solo las columnas que contengan variables num√©ricas, coloca los a√±os de nacimiento como primera columna y cambia los nombres a castellano.
 
* üìù **Ejercicio 7**: calcula una nueva columna que indique el IMC de cada personaje (define antes una funci√≥n).

* üìù **Ejercicio 8**: selecciona los 3 personajes que en m√°s pel√≠culas han salido y los 3 que menos.
 
* üìù **Ejercicio 9**: selecciona solo las columnas que se refieren a variables de color (ojos, piel, pelo) (con sufijo "color")

]

.panel[.panel-name[Sol. 1]

```{r}
# todas columnas
filtro <-
  starwars %>% filter(between(mass, 60, 90) & eye_color != "blue")
print(filtro, width = Inf)
```

]

.panel[.panel-name[Sol. 2]

```{r}
filtro <-
  starwars %>%
  filter(between(mass, 60, 90) & eye_color != "blue" &
           birth_year < 100)
print(filtro, width = Inf)
```

]

.panel[.panel-name[Sol. 3]

```{r}
# Solo name, mass, height, eye_color, birth_year
filtro %>% select(c(name, mass, height, eye_color, birth_year))
```

]

.panel[.panel-name[Sol. 4]

```{r}
filtro %>% select(c(name, mass, height, eye_color, birth_year)) %>%
  arrange(mass)
```

```{r}
filtro %>% select(c(name, mass, height, eye_color, birth_year)) %>%
  arrange(desc(mass))
```

]

.panel[.panel-name[Sol. 5]

```{r}
filtro %>% select(c(name, mass, height, eye_color, birth_year)) %>%
  arrange(height, mass)
```

]

.panel[.panel-name[Sol. 6]

```{r}
starwars %>%
  select(where(is.numeric)) %>%
  relocate(height, mass, .after = birth_year) %>%
  rename(edad = birth_year, altura = height, peso = mass)
```

]

.panel[.panel-name[Sol. 7]

Primero definimos la funci√≥n `IMC_fun` (calcula el IMC dada estatura y peso).

```{r}
IMC_fun <- function(m, h) {
  
  return(m / h^2)
}
IMC_fun(90, 1.6)
```

La funci√≥n definida como `IMC_fun()` podemos ahora aplicarla dentro del `mutate()`.

```{r}
starwars %>%
  mutate(height_m = height / 100,
         IMC = IMC_fun(mass, height_m)) %>%
  # Las movemos al inicio (por defecto las mete al final)
  relocate(height_m, IMC, .after = name)
```

]

.panel[.panel-name[Sol. 8]

 
```{r}
starwars  %>%
  mutate(n_films = map_int(films, length)) %>%
  slice_max(n_films, n = 3)
```

```{r}
starwars  %>%
  mutate(n_films = map_int(films, length)) %>%
  slice_min(n_films, n = 3)
```

]

.panel[.panel-name[Sol. 9]

```{r}
# Contiene "color" independientemente de que sea sufijo o prefijo
starwars %>% select(contains("color"))
```

]
]

---

name: dataviz
class: center, middle

# Dataviz e introducci√≥n a ggplot2

## **La gram√°tica de los gr√°ficos**

&nbsp;

El paquete `{ggplot2}` se basa en la idea propuesta en ¬´Grammar of graphics¬ª del reci√©n fallecido Wilkinson.

---

# Ejercicios

---

name: evaluacion-2
class: center, middle

# EVALUACI√ìN

## **Pr√°ctica evaluable II: primeras visualizaciones**

&nbsp;

En la carpeta [EVALUACI√ìN](https://github.com/dadosdelaplace/courses-ECI-2022/tree/main/EVALUACI%C3%93N), accede al fichero `Evaluacion_2.Rmd` en la carpeta `PR√ÅCTICA II`...

&nbsp;

La **entrega de las cinco pr√°cticas** deber√°n ser enviadas por mail antes de las 23:59h del 11 de febrero, todas en un archivo comprimido (`.zip`, `.rar`, etc), con el nombre de el/la alumno/a.


---

class: center, middle

# Ma√±ana m√°s y mejor. ¬°Much√≠simas gracias a todos/as!

Las diapositivas han sido generadas con el paquete [**{xaringan}**](https://github.com/yihui/xaringan).


Los estilos (.css y .js) de estas diapositivas est√°n basados en las diapositivas del repositorio <https://github.com/dieghernan/rpubs>

